{"version":3,"file":"evaluators.cjs","sources":["../../../../src/query/compiler/evaluators.ts"],"sourcesContent":["import {\n  EmptyReferencePathError,\n  UnknownExpressionTypeError,\n  UnknownFunctionError,\n} from \"../../errors.js\"\nimport type { BasicExpression, Func, PropRef } from \"../ir.js\"\nimport type { NamespacedRow } from \"../../types.js\"\n\n/**\n * Compiled expression evaluator function type\n */\nexport type CompiledExpression = (namespacedRow: NamespacedRow) => any\n\n/**\n * Compiled single-row expression evaluator function type\n */\nexport type CompiledSingleRowExpression = (item: Record<string, unknown>) => any\n\n/**\n * Compiles an expression into an optimized evaluator function.\n * This eliminates branching during evaluation by pre-compiling the expression structure.\n */\nexport function compileExpression(expr: BasicExpression): CompiledExpression {\n  const compiledFn = compileExpressionInternal(expr, false)\n  return compiledFn as CompiledExpression\n}\n\n/**\n * Compiles a single-row expression into an optimized evaluator function.\n */\nexport function compileSingleRowExpression(\n  expr: BasicExpression\n): CompiledSingleRowExpression {\n  const compiledFn = compileExpressionInternal(expr, true)\n  return compiledFn as CompiledSingleRowExpression\n}\n\n/**\n * Internal unified expression compiler that handles both namespaced and single-row evaluation\n */\nfunction compileExpressionInternal(\n  expr: BasicExpression,\n  isSingleRow: boolean\n): (data: any) => any {\n  switch (expr.type) {\n    case `val`: {\n      // For constant values, return a function that just returns the value\n      const value = expr.value\n      return () => value\n    }\n\n    case `ref`: {\n      // For references, compile based on evaluation mode\n      return isSingleRow ? compileSingleRowRef(expr) : compileRef(expr)\n    }\n\n    case `func`: {\n      // For functions, use the unified compiler\n      return compileFunction(expr, isSingleRow)\n    }\n\n    default:\n      throw new UnknownExpressionTypeError((expr as any).type)\n  }\n}\n\n/**\n * Compiles a reference expression into an optimized evaluator\n */\nfunction compileRef(ref: PropRef): CompiledExpression {\n  const [tableAlias, ...propertyPath] = ref.path\n\n  if (!tableAlias) {\n    throw new EmptyReferencePathError()\n  }\n\n  // Pre-compile the property path navigation\n  if (propertyPath.length === 0) {\n    // Simple table reference\n    return (namespacedRow) => namespacedRow[tableAlias]\n  } else if (propertyPath.length === 1) {\n    // Single property access - most common case\n    const prop = propertyPath[0]!\n    return (namespacedRow) => {\n      const tableData = namespacedRow[tableAlias]\n      return tableData?.[prop]\n    }\n  } else {\n    // Multiple property navigation\n    return (namespacedRow) => {\n      const tableData = namespacedRow[tableAlias]\n      if (tableData === undefined) {\n        return undefined\n      }\n\n      let value: any = tableData\n      for (const prop of propertyPath) {\n        if (value == null) {\n          return value\n        }\n        value = value[prop]\n      }\n      return value\n    }\n  }\n}\n\n/**\n * Compiles a reference expression for single-row evaluation\n */\nfunction compileSingleRowRef(ref: PropRef): CompiledSingleRowExpression {\n  const propertyPath = ref.path\n\n  // This function works for all path lengths including empty path\n  return (item) => {\n    let value: any = item\n    for (const prop of propertyPath) {\n      if (value == null) {\n        return value\n      }\n      value = value[prop]\n    }\n    return value\n  }\n}\n\n/**\n * Compiles a function expression for both namespaced and single-row evaluation\n */\nfunction compileFunction(func: Func, isSingleRow: boolean): (data: any) => any {\n  // Pre-compile all arguments using the appropriate compiler\n  const compiledArgs = func.args.map((arg) =>\n    compileExpressionInternal(arg, isSingleRow)\n  )\n\n  switch (func.name) {\n    // Comparison operators\n    case `eq`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        return a === b\n      }\n    }\n    case `gt`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        return a > b\n      }\n    }\n    case `gte`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        return a >= b\n      }\n    }\n    case `lt`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        return a < b\n      }\n    }\n    case `lte`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        return a <= b\n      }\n    }\n\n    // Boolean operators\n    case `and`:\n      return (data) => {\n        for (const compiledArg of compiledArgs) {\n          if (!compiledArg(data)) {\n            return false\n          }\n        }\n        return true\n      }\n    case `or`:\n      return (data) => {\n        for (const compiledArg of compiledArgs) {\n          if (compiledArg(data)) {\n            return true\n          }\n        }\n        return false\n      }\n    case `not`: {\n      const arg = compiledArgs[0]!\n      return (data) => !arg(data)\n    }\n\n    // Array operators\n    case `in`: {\n      const valueEvaluator = compiledArgs[0]!\n      const arrayEvaluator = compiledArgs[1]!\n      return (data) => {\n        const value = valueEvaluator(data)\n        const array = arrayEvaluator(data)\n        if (!Array.isArray(array)) {\n          return false\n        }\n        return array.includes(value)\n      }\n    }\n\n    // String operators\n    case `like`: {\n      const valueEvaluator = compiledArgs[0]!\n      const patternEvaluator = compiledArgs[1]!\n      return (data) => {\n        const value = valueEvaluator(data)\n        const pattern = patternEvaluator(data)\n        return evaluateLike(value, pattern, false)\n      }\n    }\n    case `ilike`: {\n      const valueEvaluator = compiledArgs[0]!\n      const patternEvaluator = compiledArgs[1]!\n      return (data) => {\n        const value = valueEvaluator(data)\n        const pattern = patternEvaluator(data)\n        return evaluateLike(value, pattern, true)\n      }\n    }\n\n    // String functions\n    case `upper`: {\n      const arg = compiledArgs[0]!\n      return (data) => {\n        const value = arg(data)\n        return typeof value === `string` ? value.toUpperCase() : value\n      }\n    }\n    case `lower`: {\n      const arg = compiledArgs[0]!\n      return (data) => {\n        const value = arg(data)\n        return typeof value === `string` ? value.toLowerCase() : value\n      }\n    }\n    case `length`: {\n      const arg = compiledArgs[0]!\n      return (data) => {\n        const value = arg(data)\n        if (typeof value === `string`) {\n          return value.length\n        }\n        if (Array.isArray(value)) {\n          return value.length\n        }\n        return 0\n      }\n    }\n    case `concat`:\n      return (data) => {\n        return compiledArgs\n          .map((evaluator) => {\n            const arg = evaluator(data)\n            try {\n              return String(arg ?? ``)\n            } catch {\n              try {\n                return JSON.stringify(arg) || ``\n              } catch {\n                return `[object]`\n              }\n            }\n          })\n          .join(``)\n      }\n    case `coalesce`:\n      return (data) => {\n        for (const evaluator of compiledArgs) {\n          const value = evaluator(data)\n          if (value !== null && value !== undefined) {\n            return value\n          }\n        }\n        return null\n      }\n\n    // Math functions\n    case `add`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        return (a ?? 0) + (b ?? 0)\n      }\n    }\n    case `subtract`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        return (a ?? 0) - (b ?? 0)\n      }\n    }\n    case `multiply`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        return (a ?? 0) * (b ?? 0)\n      }\n    }\n    case `divide`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        const divisor = b ?? 0\n        return divisor !== 0 ? (a ?? 0) / divisor : null\n      }\n    }\n\n    default:\n      throw new UnknownFunctionError(func.name)\n  }\n}\n\n/**\n * Evaluates LIKE/ILIKE patterns\n */\nfunction evaluateLike(\n  value: any,\n  pattern: any,\n  caseInsensitive: boolean\n): boolean {\n  if (typeof value !== `string` || typeof pattern !== `string`) {\n    return false\n  }\n\n  const searchValue = caseInsensitive ? value.toLowerCase() : value\n  const searchPattern = caseInsensitive ? pattern.toLowerCase() : pattern\n\n  // Convert SQL LIKE pattern to regex\n  // First escape all regex special chars except % and _\n  let regexPattern = searchPattern.replace(/[.*+?^${}()|[\\]\\\\]/g, `\\\\$&`)\n\n  // Then convert SQL wildcards to regex\n  regexPattern = regexPattern.replace(/%/g, `.*`) // % matches any sequence\n  regexPattern = regexPattern.replace(/_/g, `.`) // _ matches any single char\n\n  const regex = new RegExp(`^${regexPattern}$`)\n  return regex.test(searchValue)\n}\n"],"names":["UnknownExpressionTypeError","EmptyReferencePathError","UnknownFunctionError"],"mappings":"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"}