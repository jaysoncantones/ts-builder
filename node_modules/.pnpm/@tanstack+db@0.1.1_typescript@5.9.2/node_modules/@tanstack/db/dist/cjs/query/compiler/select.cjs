"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const dbIvm = require("@tanstack/db-ivm");
const evaluators = require("./evaluators.cjs");
function processSelectToResults(pipeline, select, _allInputs) {
  const compiledSelect = [];
  const spreadAliases = [];
  for (const [alias, expression] of Object.entries(select)) {
    if (alias.startsWith(`__SPREAD_SENTINEL__`)) {
      const tableAlias = alias.replace(`__SPREAD_SENTINEL__`, ``);
      spreadAliases.push(tableAlias);
    } else {
      if (isAggregateExpression(expression)) {
        compiledSelect.push({
          alias,
          compiledExpression: () => null
          // Placeholder - will be handled by GROUP BY
        });
      } else {
        compiledSelect.push({
          alias,
          compiledExpression: evaluators.compileExpression(expression)
        });
      }
    }
  }
  return pipeline.pipe(
    dbIvm.map(([key, namespacedRow]) => {
      const selectResults = {};
      for (const tableAlias of spreadAliases) {
        const tableData = namespacedRow[tableAlias];
        if (tableData && typeof tableData === `object`) {
          for (const [fieldName, fieldValue] of Object.entries(tableData)) {
            if (!(fieldName in selectResults)) {
              selectResults[fieldName] = fieldValue;
            }
          }
        }
      }
      for (const { alias, compiledExpression } of compiledSelect) {
        selectResults[alias] = compiledExpression(namespacedRow);
      }
      return [
        key,
        {
          ...namespacedRow,
          __select_results: selectResults
        }
      ];
    })
  );
}
function isAggregateExpression(expr) {
  return expr.type === `agg`;
}
exports.processSelectToResults = processSelectToResults;
//# sourceMappingURL=select.cjs.map
