"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const proxy = require("./proxy.cjs");
const SortedMap = require("./SortedMap.cjs");
const refProxy = require("./query/builder/ref-proxy.cjs");
const btreeIndex = require("./indexes/btree-index.cjs");
const lazyIndex = require("./indexes/lazy-index.cjs");
const autoIndex = require("./indexes/auto-index.cjs");
const transactions = require("./transactions.cjs");
const errors = require("./errors.cjs");
const changeEvents = require("./change-events.cjs");
function createCollection(options) {
  const collection = new CollectionImpl(options);
  if (options.utils) {
    collection.utils = { ...options.utils };
  } else {
    collection.utils = {};
  }
  return collection;
}
class CollectionImpl {
  /**
   * Creates a new Collection instance
   *
   * @param config - Configuration object for the collection
   * @throws Error if sync config is missing
   */
  constructor(config) {
    this.pendingSyncedTransactions = [];
    this.syncedMetadata = /* @__PURE__ */ new Map();
    this.optimisticUpserts = /* @__PURE__ */ new Map();
    this.optimisticDeletes = /* @__PURE__ */ new Set();
    this._size = 0;
    this.lazyIndexes = /* @__PURE__ */ new Map();
    this.resolvedIndexes = /* @__PURE__ */ new Map();
    this.isIndexesResolved = false;
    this.indexCounter = 0;
    this.changeListeners = /* @__PURE__ */ new Set();
    this.changeKeyListeners = /* @__PURE__ */ new Map();
    this.utils = {};
    this.syncedKeys = /* @__PURE__ */ new Set();
    this.preSyncVisibleState = /* @__PURE__ */ new Map();
    this.recentlySyncedKeys = /* @__PURE__ */ new Set();
    this.hasReceivedFirstCommit = false;
    this.isCommittingSyncTransactions = false;
    this.onFirstReadyCallbacks = [];
    this.hasBeenReady = false;
    this.batchedEvents = [];
    this.shouldBatchEvents = false;
    this._status = `idle`;
    this.activeSubscribersCount = 0;
    this.gcTimeoutId = null;
    this.preloadPromise = null;
    this.syncCleanupFn = null;
    this.id = ``;
    this.commitPendingTransactions = () => {
      let hasPersistingTransaction = false;
      for (const transaction of this.transactions.values()) {
        if (transaction.state === `persisting`) {
          hasPersistingTransaction = true;
          break;
        }
      }
      if (!hasPersistingTransaction) {
        this.isCommittingSyncTransactions = true;
        const changedKeys = /* @__PURE__ */ new Set();
        for (const transaction of this.pendingSyncedTransactions) {
          for (const operation of transaction.operations) {
            changedKeys.add(operation.key);
          }
        }
        let currentVisibleState = this.preSyncVisibleState;
        if (currentVisibleState.size === 0) {
          currentVisibleState = /* @__PURE__ */ new Map();
          for (const key of changedKeys) {
            const currentValue = this.get(key);
            if (currentValue !== void 0) {
              currentVisibleState.set(key, currentValue);
            }
          }
        }
        const events = [];
        const rowUpdateMode = this.config.sync.rowUpdateMode || `partial`;
        for (const transaction of this.pendingSyncedTransactions) {
          for (const operation of transaction.operations) {
            const key = operation.key;
            this.syncedKeys.add(key);
            switch (operation.type) {
              case `insert`:
                this.syncedMetadata.set(key, operation.metadata);
                break;
              case `update`:
                this.syncedMetadata.set(
                  key,
                  Object.assign(
                    {},
                    this.syncedMetadata.get(key),
                    operation.metadata
                  )
                );
                break;
              case `delete`:
                this.syncedMetadata.delete(key);
                break;
            }
            switch (operation.type) {
              case `insert`:
                this.syncedData.set(key, operation.value);
                break;
              case `update`: {
                if (rowUpdateMode === `partial`) {
                  const updatedValue = Object.assign(
                    {},
                    this.syncedData.get(key),
                    operation.value
                  );
                  this.syncedData.set(key, updatedValue);
                } else {
                  this.syncedData.set(key, operation.value);
                }
                break;
              }
              case `delete`:
                this.syncedData.delete(key);
                break;
            }
          }
        }
        this.optimisticUpserts.clear();
        this.optimisticDeletes.clear();
        this.isCommittingSyncTransactions = false;
        for (const transaction of this.transactions.values()) {
          if (![`completed`, `failed`].includes(transaction.state)) {
            for (const mutation of transaction.mutations) {
              if (mutation.collection === this && mutation.optimistic) {
                switch (mutation.type) {
                  case `insert`:
                  case `update`:
                    this.optimisticUpserts.set(
                      mutation.key,
                      mutation.modified
                    );
                    this.optimisticDeletes.delete(mutation.key);
                    break;
                  case `delete`:
                    this.optimisticUpserts.delete(mutation.key);
                    this.optimisticDeletes.add(mutation.key);
                    break;
                }
              }
            }
          }
        }
        const completedOptimisticOps = /* @__PURE__ */ new Map();
        for (const transaction of this.transactions.values()) {
          if (transaction.state === `completed`) {
            for (const mutation of transaction.mutations) {
              if (mutation.collection === this && changedKeys.has(mutation.key)) {
                completedOptimisticOps.set(mutation.key, {
                  type: mutation.type,
                  value: mutation.modified
                });
              }
            }
          }
        }
        for (const key of changedKeys) {
          const previousVisibleValue = currentVisibleState.get(key);
          const newVisibleValue = this.get(key);
          const completedOp = completedOptimisticOps.get(key);
          const isRedundantSync = completedOp && newVisibleValue !== void 0 && this.deepEqual(completedOp.value, newVisibleValue);
          if (!isRedundantSync) {
            if (previousVisibleValue === void 0 && newVisibleValue !== void 0) {
              events.push({
                type: `insert`,
                key,
                value: newVisibleValue
              });
            } else if (previousVisibleValue !== void 0 && newVisibleValue === void 0) {
              events.push({
                type: `delete`,
                key,
                value: previousVisibleValue
              });
            } else if (previousVisibleValue !== void 0 && newVisibleValue !== void 0 && !this.deepEqual(previousVisibleValue, newVisibleValue)) {
              events.push({
                type: `update`,
                key,
                value: newVisibleValue,
                previousValue: previousVisibleValue
              });
            }
          }
        }
        this._size = this.calculateSize();
        if (events.length > 0) {
          this.updateIndexes(events);
        }
        this.emitEvents(events, true);
        this.pendingSyncedTransactions = [];
        this.preSyncVisibleState.clear();
        Promise.resolve().then(() => {
          this.recentlySyncedKeys.clear();
        });
        if (!this.hasReceivedFirstCommit) {
          this.hasReceivedFirstCommit = true;
          const callbacks = [...this.onFirstReadyCallbacks];
          this.onFirstReadyCallbacks = [];
          callbacks.forEach((callback) => callback());
        }
      }
    };
    this.insert = (data, config2) => {
      this.validateCollectionUsable(`insert`);
      const ambientTransaction = transactions.getActiveTransaction();
      if (!ambientTransaction && !this.config.onInsert) {
        throw new errors.MissingInsertHandlerError();
      }
      const items = Array.isArray(data) ? data : [data];
      const mutations = [];
      items.forEach((item) => {
        var _a, _b;
        const validatedData = this.validateData(item, `insert`);
        const key = this.getKeyFromItem(validatedData);
        if (this.has(key)) {
          throw new errors.DuplicateKeyError(key);
        }
        const globalKey = this.generateGlobalKey(key, item);
        const mutation = {
          mutationId: crypto.randomUUID(),
          original: {},
          modified: validatedData,
          // Pick the values from validatedData based on what's passed in - this is for cases
          // where a schema has default values. The validated data has the extra default
          // values but for changes, we just want to show the data that was actually passed in.
          changes: Object.fromEntries(
            Object.keys(item).map((k) => [
              k,
              validatedData[k]
            ])
          ),
          globalKey,
          key,
          metadata: config2 == null ? void 0 : config2.metadata,
          syncMetadata: ((_b = (_a = this.config.sync).getSyncMetadata) == null ? void 0 : _b.call(_a)) || {},
          optimistic: (config2 == null ? void 0 : config2.optimistic) ?? true,
          type: `insert`,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date(),
          collection: this
        };
        mutations.push(mutation);
      });
      if (ambientTransaction) {
        ambientTransaction.applyMutations(mutations);
        this.transactions.set(ambientTransaction.id, ambientTransaction);
        this.scheduleTransactionCleanup(ambientTransaction);
        this.recomputeOptimisticState(true);
        return ambientTransaction;
      } else {
        const directOpTransaction = transactions.createTransaction({
          mutationFn: async (params) => {
            return await this.config.onInsert({
              transaction: params.transaction,
              collection: this
            });
          }
        });
        directOpTransaction.applyMutations(mutations);
        directOpTransaction.commit();
        this.transactions.set(directOpTransaction.id, directOpTransaction);
        this.scheduleTransactionCleanup(directOpTransaction);
        this.recomputeOptimisticState(true);
        return directOpTransaction;
      }
    };
    this.delete = (keys, config2) => {
      this.validateCollectionUsable(`delete`);
      const ambientTransaction = transactions.getActiveTransaction();
      if (!ambientTransaction && !this.config.onDelete) {
        throw new errors.MissingDeleteHandlerError();
      }
      if (Array.isArray(keys) && keys.length === 0) {
        throw new errors.NoKeysPassedToDeleteError();
      }
      const keysArray = Array.isArray(keys) ? keys : [keys];
      const mutations = [];
      for (const key of keysArray) {
        if (!this.has(key)) {
          throw new errors.DeleteKeyNotFoundError(key);
        }
        const globalKey = this.generateGlobalKey(key, this.get(key));
        const mutation = {
          mutationId: crypto.randomUUID(),
          original: this.get(key),
          modified: this.get(key),
          changes: this.get(key),
          globalKey,
          key,
          metadata: config2 == null ? void 0 : config2.metadata,
          syncMetadata: this.syncedMetadata.get(key) || {},
          optimistic: (config2 == null ? void 0 : config2.optimistic) ?? true,
          type: `delete`,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date(),
          collection: this
        };
        mutations.push(mutation);
      }
      if (ambientTransaction) {
        ambientTransaction.applyMutations(mutations);
        this.transactions.set(ambientTransaction.id, ambientTransaction);
        this.scheduleTransactionCleanup(ambientTransaction);
        this.recomputeOptimisticState(true);
        return ambientTransaction;
      }
      const directOpTransaction = transactions.createTransaction({
        autoCommit: true,
        mutationFn: async (params) => {
          return this.config.onDelete({
            transaction: params.transaction,
            collection: this
          });
        }
      });
      directOpTransaction.applyMutations(mutations);
      directOpTransaction.commit();
      this.transactions.set(directOpTransaction.id, directOpTransaction);
      this.scheduleTransactionCleanup(directOpTransaction);
      this.recomputeOptimisticState(true);
      return directOpTransaction;
    };
    if (!config) {
      throw new errors.CollectionRequiresConfigError();
    }
    if (config.id) {
      this.id = config.id;
    } else {
      this.id = crypto.randomUUID();
    }
    if (!config.sync) {
      throw new errors.CollectionRequiresSyncConfigError();
    }
    this.transactions = new SortedMap.SortedMap(
      (a, b) => a.compareCreatedAt(b)
    );
    this.config = {
      ...config,
      autoIndex: config.autoIndex ?? `eager`
    };
    if (this.config.compare) {
      this.syncedData = new SortedMap.SortedMap(this.config.compare);
    } else {
      this.syncedData = /* @__PURE__ */ new Map();
    }
    if (config.startSync === true) {
      this.startSync();
    }
  }
  /**
   * Register a callback to be executed when the collection first becomes ready
   * Useful for preloading collections
   * @param callback Function to call when the collection first becomes ready
   * @example
   * collection.onFirstReady(() => {
   *   console.log('Collection is ready for the first time')
   *   // Safe to access collection.state now
   * })
   */
  onFirstReady(callback) {
    if (this.hasBeenReady) {
      callback();
      return;
    }
    this.onFirstReadyCallbacks.push(callback);
  }
  /**
   * Check if the collection is ready for use
   * Returns true if the collection has been marked as ready by its sync implementation
   * @returns true if the collection is ready, false otherwise
   * @example
   * if (collection.isReady()) {
   *   console.log('Collection is ready, data is available')
   *   // Safe to access collection.state
   * } else {
   *   console.log('Collection is still loading')
   * }
   */
  isReady() {
    return this._status === `ready`;
  }
  /**
   * Mark the collection as ready for use
   * This is called by sync implementations to explicitly signal that the collection is ready,
   * providing a more intuitive alternative to using commits for readiness signaling
   * @private - Should only be called by sync implementations
   */
  markReady() {
    if (this._status === `loading` || this._status === `initialCommit`) {
      this.setStatus(`ready`);
      if (!this.hasBeenReady) {
        this.hasBeenReady = true;
        if (!this.hasReceivedFirstCommit) {
          this.hasReceivedFirstCommit = true;
        }
        const callbacks = [...this.onFirstReadyCallbacks];
        this.onFirstReadyCallbacks = [];
        callbacks.forEach((callback) => callback());
        if (this.size === 0 && this.changeListeners.size > 0) {
          this.emitEmptyReadyEvent();
        }
      }
    }
  }
  /**
   * Gets the current status of the collection
   */
  get status() {
    return this._status;
  }
  /**
   * Validates that the collection is in a usable state for data operations
   * @private
   */
  validateCollectionUsable(operation) {
    switch (this._status) {
      case `error`:
        throw new errors.CollectionInErrorStateError(operation, this.id);
      case `cleaned-up`:
        this.startSync();
        break;
    }
  }
  /**
   * Validates state transitions to prevent invalid status changes
   * @private
   */
  validateStatusTransition(from, to) {
    if (from === to) {
      return;
    }
    const validTransitions = {
      idle: [`loading`, `error`, `cleaned-up`],
      loading: [`initialCommit`, `ready`, `error`, `cleaned-up`],
      initialCommit: [`ready`, `error`, `cleaned-up`],
      ready: [`cleaned-up`, `error`],
      error: [`cleaned-up`, `idle`],
      "cleaned-up": [`loading`, `error`]
    };
    if (!validTransitions[from].includes(to)) {
      throw new errors.InvalidCollectionStatusTransitionError(from, to, this.id);
    }
  }
  /**
   * Safely update the collection status with validation
   * @private
   */
  setStatus(newStatus) {
    this.validateStatusTransition(this._status, newStatus);
    this._status = newStatus;
    if (newStatus === `ready` && !this.isIndexesResolved) {
      this.resolveAllIndexes().catch((error) => {
        console.warn(`Failed to resolve indexes:`, error);
      });
    }
  }
  /**
   * Start sync immediately - internal method for compiled queries
   * This bypasses lazy loading for special cases like live query results
   */
  startSyncImmediate() {
    this.startSync();
  }
  /**
   * Start the sync process for this collection
   * This is called when the collection is first accessed or preloaded
   */
  startSync() {
    if (this._status !== `idle` && this._status !== `cleaned-up`) {
      return;
    }
    this.setStatus(`loading`);
    try {
      const cleanupFn = this.config.sync.sync({
        collection: this,
        begin: () => {
          this.pendingSyncedTransactions.push({
            committed: false,
            operations: []
          });
        },
        write: (messageWithoutKey) => {
          const pendingTransaction = this.pendingSyncedTransactions[this.pendingSyncedTransactions.length - 1];
          if (!pendingTransaction) {
            throw new errors.NoPendingSyncTransactionWriteError();
          }
          if (pendingTransaction.committed) {
            throw new errors.SyncTransactionAlreadyCommittedWriteError();
          }
          const key = this.getKeyFromItem(messageWithoutKey.value);
          if (messageWithoutKey.type === `insert`) {
            if (this.syncedData.has(key) && !pendingTransaction.operations.some(
              (op) => op.key === key && op.type === `delete`
            )) {
              throw new errors.DuplicateKeySyncError(key, this.id);
            }
          }
          const message = {
            ...messageWithoutKey,
            key
          };
          pendingTransaction.operations.push(message);
        },
        commit: () => {
          const pendingTransaction = this.pendingSyncedTransactions[this.pendingSyncedTransactions.length - 1];
          if (!pendingTransaction) {
            throw new errors.NoPendingSyncTransactionCommitError();
          }
          if (pendingTransaction.committed) {
            throw new errors.SyncTransactionAlreadyCommittedError();
          }
          pendingTransaction.committed = true;
          if (this._status === `loading`) {
            this.setStatus(`initialCommit`);
          }
          this.commitPendingTransactions();
        },
        markReady: () => {
          this.markReady();
        }
      });
      this.syncCleanupFn = typeof cleanupFn === `function` ? cleanupFn : null;
    } catch (error) {
      this.setStatus(`error`);
      throw error;
    }
  }
  /**
   * Preload the collection data by starting sync if not already started
   * Multiple concurrent calls will share the same promise
   */
  preload() {
    if (this.preloadPromise) {
      return this.preloadPromise;
    }
    this.preloadPromise = new Promise((resolve, reject) => {
      if (this._status === `ready`) {
        resolve();
        return;
      }
      if (this._status === `error`) {
        reject(new errors.CollectionIsInErrorStateError());
        return;
      }
      this.onFirstReady(() => {
        resolve();
      });
      if (this._status === `idle` || this._status === `cleaned-up`) {
        try {
          this.startSync();
        } catch (error) {
          reject(error);
          return;
        }
      }
    });
    return this.preloadPromise;
  }
  /**
   * Clean up the collection by stopping sync and clearing data
   * This can be called manually or automatically by garbage collection
   */
  async cleanup() {
    if (this.gcTimeoutId) {
      clearTimeout(this.gcTimeoutId);
      this.gcTimeoutId = null;
    }
    try {
      if (this.syncCleanupFn) {
        this.syncCleanupFn();
        this.syncCleanupFn = null;
      }
    } catch (error) {
      queueMicrotask(() => {
        if (error instanceof Error) {
          const wrappedError = new errors.SyncCleanupError(this.id, error);
          wrappedError.cause = error;
          wrappedError.stack = error.stack;
          throw wrappedError;
        } else {
          throw new errors.SyncCleanupError(this.id, error);
        }
      });
    }
    this.syncedData.clear();
    this.syncedMetadata.clear();
    this.optimisticUpserts.clear();
    this.optimisticDeletes.clear();
    this._size = 0;
    this.pendingSyncedTransactions = [];
    this.syncedKeys.clear();
    this.hasReceivedFirstCommit = false;
    this.hasBeenReady = false;
    this.onFirstReadyCallbacks = [];
    this.preloadPromise = null;
    this.batchedEvents = [];
    this.shouldBatchEvents = false;
    this.setStatus(`cleaned-up`);
    return Promise.resolve();
  }
  /**
   * Start the garbage collection timer
   * Called when the collection becomes inactive (no subscribers)
   */
  startGCTimer() {
    if (this.gcTimeoutId) {
      clearTimeout(this.gcTimeoutId);
    }
    const gcTime = this.config.gcTime ?? 3e5;
    this.gcTimeoutId = setTimeout(() => {
      if (this.activeSubscribersCount === 0) {
        this.cleanup();
      }
    }, gcTime);
  }
  /**
   * Cancel the garbage collection timer
   * Called when the collection becomes active again
   */
  cancelGCTimer() {
    if (this.gcTimeoutId) {
      clearTimeout(this.gcTimeoutId);
      this.gcTimeoutId = null;
    }
  }
  /**
   * Increment the active subscribers count and start sync if needed
   */
  addSubscriber() {
    this.activeSubscribersCount++;
    this.cancelGCTimer();
    if (this._status === `cleaned-up` || this._status === `idle`) {
      this.startSync();
    }
  }
  /**
   * Decrement the active subscribers count and start GC timer if needed
   */
  removeSubscriber() {
    this.activeSubscribersCount--;
    if (this.activeSubscribersCount === 0) {
      this.activeSubscribersCount = 0;
      this.startGCTimer();
    } else if (this.activeSubscribersCount < 0) {
      throw new errors.NegativeActiveSubscribersError();
    }
  }
  /**
   * Recompute optimistic state from active transactions
   */
  recomputeOptimisticState(triggeredByUserAction = false) {
    if (this.isCommittingSyncTransactions) {
      return;
    }
    const previousState = new Map(this.optimisticUpserts);
    const previousDeletes = new Set(this.optimisticDeletes);
    this.optimisticUpserts.clear();
    this.optimisticDeletes.clear();
    const activeTransactions = [];
    for (const transaction of this.transactions.values()) {
      if (![`completed`, `failed`].includes(transaction.state)) {
        activeTransactions.push(transaction);
      }
    }
    for (const transaction of activeTransactions) {
      for (const mutation of transaction.mutations) {
        if (mutation.collection === this && mutation.optimistic) {
          switch (mutation.type) {
            case `insert`:
            case `update`:
              this.optimisticUpserts.set(mutation.key, mutation.modified);
              this.optimisticDeletes.delete(mutation.key);
              break;
            case `delete`:
              this.optimisticUpserts.delete(mutation.key);
              this.optimisticDeletes.add(mutation.key);
              break;
          }
        }
      }
    }
    this._size = this.calculateSize();
    const events = [];
    this.collectOptimisticChanges(previousState, previousDeletes, events);
    const filteredEventsBySyncStatus = events.filter((event) => {
      if (!this.recentlySyncedKeys.has(event.key)) {
        return true;
      }
      if (triggeredByUserAction) {
        return true;
      }
      return false;
    });
    if (this.pendingSyncedTransactions.length > 0 && !triggeredByUserAction) {
      const pendingSyncKeys = /* @__PURE__ */ new Set();
      for (const transaction of this.pendingSyncedTransactions) {
        for (const operation of transaction.operations) {
          pendingSyncKeys.add(operation.key);
        }
      }
      const filteredEvents = filteredEventsBySyncStatus.filter((event) => {
        if (event.type === `delete` && pendingSyncKeys.has(event.key)) {
          const hasActiveOptimisticMutation = activeTransactions.some(
            (tx) => tx.mutations.some(
              (m) => m.collection === this && m.key === event.key
            )
          );
          if (!hasActiveOptimisticMutation) {
            return false;
          }
        }
        return true;
      });
      if (filteredEvents.length > 0) {
        this.updateIndexes(filteredEvents);
      }
      this.emitEvents(filteredEvents, triggeredByUserAction);
    } else {
      if (filteredEventsBySyncStatus.length > 0) {
        this.updateIndexes(filteredEventsBySyncStatus);
      }
      this.emitEvents(filteredEventsBySyncStatus, triggeredByUserAction);
    }
  }
  /**
   * Calculate the current size based on synced data and optimistic changes
   */
  calculateSize() {
    const syncedSize = this.syncedData.size;
    const deletesFromSynced = Array.from(this.optimisticDeletes).filter(
      (key) => this.syncedData.has(key) && !this.optimisticUpserts.has(key)
    ).length;
    const upsertsNotInSynced = Array.from(this.optimisticUpserts.keys()).filter(
      (key) => !this.syncedData.has(key)
    ).length;
    return syncedSize - deletesFromSynced + upsertsNotInSynced;
  }
  /**
   * Collect events for optimistic changes
   */
  collectOptimisticChanges(previousUpserts, previousDeletes, events) {
    const allKeys = /* @__PURE__ */ new Set([
      ...previousUpserts.keys(),
      ...this.optimisticUpserts.keys(),
      ...previousDeletes,
      ...this.optimisticDeletes
    ]);
    for (const key of allKeys) {
      const currentValue = this.get(key);
      const previousValue = this.getPreviousValue(
        key,
        previousUpserts,
        previousDeletes
      );
      if (previousValue !== void 0 && currentValue === void 0) {
        events.push({ type: `delete`, key, value: previousValue });
      } else if (previousValue === void 0 && currentValue !== void 0) {
        events.push({ type: `insert`, key, value: currentValue });
      } else if (previousValue !== void 0 && currentValue !== void 0 && previousValue !== currentValue) {
        events.push({
          type: `update`,
          key,
          value: currentValue,
          previousValue
        });
      }
    }
  }
  /**
   * Get the previous value for a key given previous optimistic state
   */
  getPreviousValue(key, previousUpserts, previousDeletes) {
    if (previousDeletes.has(key)) {
      return void 0;
    }
    if (previousUpserts.has(key)) {
      return previousUpserts.get(key);
    }
    return this.syncedData.get(key);
  }
  /**
   * Emit an empty ready event to notify subscribers that the collection is ready
   * This bypasses the normal empty array check in emitEvents
   */
  emitEmptyReadyEvent() {
    for (const listener of this.changeListeners) {
      listener([]);
    }
  }
  /**
   * Emit events either immediately or batch them for later emission
   */
  emitEvents(changes, forceEmit = false) {
    if (this.shouldBatchEvents && !forceEmit) {
      this.batchedEvents.push(...changes);
      return;
    }
    let eventsToEmit = changes;
    if (this.batchedEvents.length > 0 && forceEmit) {
      eventsToEmit = [...this.batchedEvents, ...changes];
      this.batchedEvents = [];
      this.shouldBatchEvents = false;
    }
    if (eventsToEmit.length === 0) return;
    for (const listener of this.changeListeners) {
      listener(eventsToEmit);
    }
    if (this.changeKeyListeners.size > 0) {
      const changesByKey = /* @__PURE__ */ new Map();
      for (const change of eventsToEmit) {
        if (this.changeKeyListeners.has(change.key)) {
          if (!changesByKey.has(change.key)) {
            changesByKey.set(change.key, []);
          }
          changesByKey.get(change.key).push(change);
        }
      }
      for (const [key, keyChanges] of changesByKey) {
        const keyListeners = this.changeKeyListeners.get(key);
        for (const listener of keyListeners) {
          listener(keyChanges);
        }
      }
    }
  }
  /**
   * Get the current value for a key (virtual derived state)
   */
  get(key) {
    if (this.optimisticDeletes.has(key)) {
      return void 0;
    }
    if (this.optimisticUpserts.has(key)) {
      return this.optimisticUpserts.get(key);
    }
    return this.syncedData.get(key);
  }
  /**
   * Check if a key exists in the collection (virtual derived state)
   */
  has(key) {
    if (this.optimisticDeletes.has(key)) {
      return false;
    }
    if (this.optimisticUpserts.has(key)) {
      return true;
    }
    return this.syncedData.has(key);
  }
  /**
   * Get the current size of the collection (cached)
   */
  get size() {
    return this._size;
  }
  /**
   * Get all keys (virtual derived state)
   */
  *keys() {
    for (const key of this.syncedData.keys()) {
      if (!this.optimisticDeletes.has(key)) {
        yield key;
      }
    }
    for (const key of this.optimisticUpserts.keys()) {
      if (!this.syncedData.has(key) && !this.optimisticDeletes.has(key)) {
        yield key;
      }
    }
  }
  /**
   * Get all values (virtual derived state)
   */
  *values() {
    for (const key of this.keys()) {
      const value = this.get(key);
      if (value !== void 0) {
        yield value;
      }
    }
  }
  /**
   * Get all entries (virtual derived state)
   */
  *entries() {
    for (const key of this.keys()) {
      const value = this.get(key);
      if (value !== void 0) {
        yield [key, value];
      }
    }
  }
  /**
   * Get all entries (virtual derived state)
   */
  *[Symbol.iterator]() {
    for (const [key, value] of this.entries()) {
      yield [key, value];
    }
  }
  /**
   * Execute a callback for each entry in the collection
   */
  forEach(callbackfn) {
    let index = 0;
    for (const [key, value] of this.entries()) {
      callbackfn(value, key, index++);
    }
  }
  /**
   * Create a new array with the results of calling a function for each entry in the collection
   */
  map(callbackfn) {
    const result = [];
    let index = 0;
    for (const [key, value] of this.entries()) {
      result.push(callbackfn(value, key, index++));
    }
    return result;
  }
  /**
   * Schedule cleanup of a transaction when it completes
   * @private
   */
  scheduleTransactionCleanup(transaction) {
    if (transaction.state === `completed`) {
      this.transactions.delete(transaction.id);
      return;
    }
    transaction.isPersisted.promise.then(() => {
      this.transactions.delete(transaction.id);
    }).catch(() => {
    });
  }
  ensureStandardSchema(schema) {
    if (schema && `~standard` in schema) {
      return schema;
    }
    throw new errors.InvalidSchemaError();
  }
  getKeyFromItem(item) {
    return this.config.getKey(item);
  }
  generateGlobalKey(key, item) {
    if (typeof key === `undefined`) {
      throw new errors.UndefinedKeyError(item);
    }
    return `KEY::${this.id}/${key}`;
  }
  /**
   * Creates an index on a collection for faster queries.
   * Indexes significantly improve query performance by allowing binary search
   * and range queries instead of full scans.
   *
   * @template TResolver - The type of the index resolver (constructor or async loader)
   * @param indexCallback - Function that extracts the indexed value from each item
   * @param config - Configuration including index type and type-specific options
   * @returns An index proxy that provides access to the index when ready
   *
   * @example
   * // Create a default B+ tree index
   * const ageIndex = collection.createIndex((row) => row.age)
   *
   * // Create a ordered index with custom options
   * const ageIndex = collection.createIndex((row) => row.age, {
   *   indexType: BTreeIndex,
   *   options: { compareFn: customComparator },
   *   name: 'age_btree'
   * })
   *
   * // Create an async-loaded index
   * const textIndex = collection.createIndex((row) => row.content, {
   *   indexType: async () => {
   *     const { FullTextIndex } = await import('./indexes/fulltext.js')
   *     return FullTextIndex
   *   },
   *   options: { language: 'en' }
   * })
   */
  createIndex(indexCallback, config = {}) {
    this.validateCollectionUsable(`createIndex`);
    const indexId = ++this.indexCounter;
    const singleRowRefProxy = refProxy.createSingleRowRefProxy();
    const indexExpression = indexCallback(singleRowRefProxy);
    const expression = refProxy.toExpression(indexExpression);
    const resolver = config.indexType ?? btreeIndex.BTreeIndex;
    const lazyIndex$1 = new lazyIndex.LazyIndexWrapper(
      indexId,
      expression,
      config.name,
      resolver,
      config.options,
      this.entries()
    );
    this.lazyIndexes.set(indexId, lazyIndex$1);
    if (resolver === btreeIndex.BTreeIndex) {
      try {
        const resolvedIndex = lazyIndex$1.getResolved();
        this.resolvedIndexes.set(indexId, resolvedIndex);
      } catch (error) {
        console.warn(`Failed to resolve BTreeIndex:`, error);
      }
    } else if (typeof resolver === `function` && resolver.prototype) {
      try {
        const resolvedIndex = lazyIndex$1.getResolved();
        this.resolvedIndexes.set(indexId, resolvedIndex);
      } catch {
        this.resolveSingleIndex(indexId, lazyIndex$1).catch((error) => {
          console.warn(`Failed to resolve single index:`, error);
        });
      }
    } else if (this.isIndexesResolved) {
      this.resolveSingleIndex(indexId, lazyIndex$1).catch((error) => {
        console.warn(`Failed to resolve single index:`, error);
      });
    }
    return new lazyIndex.IndexProxy(indexId, lazyIndex$1);
  }
  /**
   * Resolve all lazy indexes (called when collection first syncs)
   * @private
   */
  async resolveAllIndexes() {
    if (this.isIndexesResolved) return;
    const resolutionPromises = Array.from(this.lazyIndexes.entries()).map(
      async ([indexId, lazyIndex2]) => {
        const resolvedIndex = await lazyIndex2.resolve();
        resolvedIndex.build(this.entries());
        this.resolvedIndexes.set(indexId, resolvedIndex);
        return { indexId, resolvedIndex };
      }
    );
    await Promise.all(resolutionPromises);
    this.isIndexesResolved = true;
  }
  /**
   * Resolve a single index immediately
   * @private
   */
  async resolveSingleIndex(indexId, lazyIndex2) {
    const resolvedIndex = await lazyIndex2.resolve();
    resolvedIndex.build(this.entries());
    this.resolvedIndexes.set(indexId, resolvedIndex);
    return resolvedIndex;
  }
  /**
   * Get resolved indexes for query optimization
   */
  get indexes() {
    return this.resolvedIndexes;
  }
  /**
   * Updates all indexes when the collection changes
   * @private
   */
  updateIndexes(changes) {
    for (const index of this.resolvedIndexes.values()) {
      for (const change of changes) {
        switch (change.type) {
          case `insert`:
            index.add(change.key, change.value);
            break;
          case `update`:
            if (change.previousValue) {
              index.update(change.key, change.previousValue, change.value);
            } else {
              index.add(change.key, change.value);
            }
            break;
          case `delete`:
            index.remove(change.key, change.value);
            break;
        }
      }
    }
  }
  deepEqual(a, b) {
    if (a === b) return true;
    if (a == null || b == null) return false;
    if (typeof a !== typeof b) return false;
    if (typeof a === `object`) {
      if (Array.isArray(a) !== Array.isArray(b)) return false;
      const keysA = Object.keys(a);
      const keysB = Object.keys(b);
      if (keysA.length !== keysB.length) return false;
      const keysBSet = new Set(keysB);
      for (const key of keysA) {
        if (!keysBSet.has(key)) return false;
        if (!this.deepEqual(a[key], b[key])) return false;
      }
      return true;
    }
    return false;
  }
  validateData(data, type, key) {
    if (!this.config.schema) return data;
    const standardSchema = this.ensureStandardSchema(this.config.schema);
    if (type === `update` && key) {
      const existingData = this.get(key);
      if (existingData && data && typeof data === `object` && typeof existingData === `object`) {
        const mergedData = Object.assign({}, existingData, data);
        const result2 = standardSchema[`~standard`].validate(mergedData);
        if (result2 instanceof Promise) {
          throw new errors.SchemaMustBeSynchronousError();
        }
        if (`issues` in result2 && result2.issues) {
          const typedIssues = result2.issues.map((issue) => {
            var _a;
            return {
              message: issue.message,
              path: (_a = issue.path) == null ? void 0 : _a.map((p) => String(p))
            };
          });
          throw new errors.SchemaValidationError(type, typedIssues);
        }
        return data;
      }
    }
    const result = standardSchema[`~standard`].validate(data);
    if (result instanceof Promise) {
      throw new errors.SchemaMustBeSynchronousError();
    }
    if (`issues` in result && result.issues) {
      const typedIssues = result.issues.map((issue) => {
        var _a;
        return {
          message: issue.message,
          path: (_a = issue.path) == null ? void 0 : _a.map((p) => String(p))
        };
      });
      throw new errors.SchemaValidationError(type, typedIssues);
    }
    return result.value;
  }
  update(keys, configOrCallback, maybeCallback) {
    if (typeof keys === `undefined`) {
      throw new errors.MissingUpdateArgumentError();
    }
    this.validateCollectionUsable(`update`);
    const ambientTransaction = transactions.getActiveTransaction();
    if (!ambientTransaction && !this.config.onUpdate) {
      throw new errors.MissingUpdateHandlerError();
    }
    const isArray = Array.isArray(keys);
    const keysArray = isArray ? keys : [keys];
    if (isArray && keysArray.length === 0) {
      throw new errors.NoKeysPassedToUpdateError();
    }
    const callback = typeof configOrCallback === `function` ? configOrCallback : maybeCallback;
    const config = typeof configOrCallback === `function` ? {} : configOrCallback;
    const currentObjects = keysArray.map((key) => {
      const item = this.get(key);
      if (!item) {
        throw new errors.UpdateKeyNotFoundError(key);
      }
      return item;
    });
    let changesArray;
    if (isArray) {
      changesArray = proxy.withArrayChangeTracking(
        currentObjects,
        callback
      );
    } else {
      const result = proxy.withChangeTracking(
        currentObjects[0],
        callback
      );
      changesArray = [result];
    }
    const mutations = keysArray.map((key, index) => {
      const itemChanges = changesArray[index];
      if (!itemChanges || Object.keys(itemChanges).length === 0) {
        return null;
      }
      const originalItem = currentObjects[index];
      const validatedUpdatePayload = this.validateData(
        itemChanges,
        `update`,
        key
      );
      const modifiedItem = Object.assign(
        {},
        originalItem,
        validatedUpdatePayload
      );
      const originalItemId = this.getKeyFromItem(originalItem);
      const modifiedItemId = this.getKeyFromItem(modifiedItem);
      if (originalItemId !== modifiedItemId) {
        throw new errors.KeyUpdateNotAllowedError(originalItemId, modifiedItemId);
      }
      const globalKey = this.generateGlobalKey(modifiedItemId, modifiedItem);
      return {
        mutationId: crypto.randomUUID(),
        original: originalItem,
        modified: modifiedItem,
        changes: validatedUpdatePayload,
        globalKey,
        key,
        metadata: config.metadata,
        syncMetadata: this.syncedMetadata.get(key) || {},
        optimistic: config.optimistic ?? true,
        type: `update`,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date(),
        collection: this
      };
    }).filter(Boolean);
    if (mutations.length === 0) {
      const emptyTransaction = transactions.createTransaction({
        mutationFn: async () => {
        }
      });
      emptyTransaction.commit();
      this.scheduleTransactionCleanup(emptyTransaction);
      return emptyTransaction;
    }
    if (ambientTransaction) {
      ambientTransaction.applyMutations(mutations);
      this.transactions.set(ambientTransaction.id, ambientTransaction);
      this.scheduleTransactionCleanup(ambientTransaction);
      this.recomputeOptimisticState(true);
      return ambientTransaction;
    }
    const directOpTransaction = transactions.createTransaction({
      mutationFn: async (params) => {
        return this.config.onUpdate({
          transaction: params.transaction,
          collection: this
        });
      }
    });
    directOpTransaction.applyMutations(mutations);
    directOpTransaction.commit();
    this.transactions.set(directOpTransaction.id, directOpTransaction);
    this.scheduleTransactionCleanup(directOpTransaction);
    this.recomputeOptimisticState(true);
    return directOpTransaction;
  }
  /**
   * Gets the current state of the collection as a Map
   * @returns Map containing all items in the collection, with keys as identifiers
   * @example
   * const itemsMap = collection.state
   * console.log(`Collection has ${itemsMap.size} items`)
   *
   * for (const [key, item] of itemsMap) {
   *   console.log(`${key}: ${item.title}`)
   * }
   *
   * // Check if specific item exists
   * if (itemsMap.has("todo-1")) {
   *   console.log("Todo 1 exists:", itemsMap.get("todo-1"))
   * }
   */
  get state() {
    const result = /* @__PURE__ */ new Map();
    for (const [key, value] of this.entries()) {
      result.set(key, value);
    }
    return result;
  }
  /**
   * Gets the current state of the collection as a Map, but only resolves when data is available
   * Waits for the first sync commit to complete before resolving
   *
   * @returns Promise that resolves to a Map containing all items in the collection
   */
  stateWhenReady() {
    if (this.size > 0 || this.isReady()) {
      return Promise.resolve(this.state);
    }
    return new Promise((resolve) => {
      this.onFirstReady(() => {
        resolve(this.state);
      });
    });
  }
  /**
   * Gets the current state of the collection as an Array
   *
   * @returns An Array containing all items in the collection
   */
  get toArray() {
    return Array.from(this.values());
  }
  /**
   * Gets the current state of the collection as an Array, but only resolves when data is available
   * Waits for the first sync commit to complete before resolving
   *
   * @returns Promise that resolves to an Array containing all items in the collection
   */
  toArrayWhenReady() {
    if (this.size > 0 || this.isReady()) {
      return Promise.resolve(this.toArray);
    }
    return new Promise((resolve) => {
      this.onFirstReady(() => {
        resolve(this.toArray);
      });
    });
  }
  /**
   * Returns the current state of the collection as an array of changes
   * @param options - Options including optional where filter
   * @returns An array of changes
   * @example
   * // Get all items as changes
   * const allChanges = collection.currentStateAsChanges()
   *
   * // Get only items matching a condition
   * const activeChanges = collection.currentStateAsChanges({
   *   where: (row) => row.status === 'active'
   * })
   *
   * // Get only items using a pre-compiled expression
   * const activeChanges = collection.currentStateAsChanges({
   *   whereExpression: eq(row.status, 'active')
   * })
   */
  currentStateAsChanges(options = {}) {
    return changeEvents.currentStateAsChanges(this, options);
  }
  /**
   * Subscribe to changes in the collection
   * @param callback - Function called when items change
   * @param options - Subscription options including includeInitialState and where filter
   * @returns Unsubscribe function - Call this to stop listening for changes
   * @example
   * // Basic subscription
   * const unsubscribe = collection.subscribeChanges((changes) => {
   *   changes.forEach(change => {
   *     console.log(`${change.type}: ${change.key}`, change.value)
   *   })
   * })
   *
   * // Later: unsubscribe()
   *
   * @example
   * // Include current state immediately
   * const unsubscribe = collection.subscribeChanges((changes) => {
   *   updateUI(changes)
   * }, { includeInitialState: true })
   *
   * @example
   * // Subscribe only to changes matching a condition
   * const unsubscribe = collection.subscribeChanges((changes) => {
   *   updateUI(changes)
   * }, {
   *   includeInitialState: true,
   *   where: (row) => row.status === 'active'
   * })
   *
   * @example
   * // Subscribe using a pre-compiled expression
   * const unsubscribe = collection.subscribeChanges((changes) => {
   *   updateUI(changes)
   * }, {
   *   includeInitialState: true,
   *   whereExpression: eq(row.status, 'active')
   * })
   */
  subscribeChanges(callback, options = {}) {
    this.addSubscriber();
    if (options.whereExpression) {
      autoIndex.ensureIndexForExpression(options.whereExpression, this);
    }
    const filteredCallback = options.where || options.whereExpression ? changeEvents.createFilteredCallback(callback, options) : callback;
    if (options.includeInitialState) {
      const initialChanges = this.currentStateAsChanges({
        where: options.where,
        whereExpression: options.whereExpression
      });
      filteredCallback(initialChanges);
    }
    this.changeListeners.add(filteredCallback);
    return () => {
      this.changeListeners.delete(filteredCallback);
      this.removeSubscriber();
    };
  }
  /**
   * Subscribe to changes for a specific key
   */
  subscribeChangesKey(key, listener, { includeInitialState = false } = {}) {
    this.addSubscriber();
    if (!this.changeKeyListeners.has(key)) {
      this.changeKeyListeners.set(key, /* @__PURE__ */ new Set());
    }
    if (includeInitialState) {
      listener([
        {
          type: `insert`,
          key,
          value: this.get(key)
        }
      ]);
    }
    this.changeKeyListeners.get(key).add(listener);
    return () => {
      const listeners = this.changeKeyListeners.get(key);
      if (listeners) {
        listeners.delete(listener);
        if (listeners.size === 0) {
          this.changeKeyListeners.delete(key);
        }
      }
      this.removeSubscriber();
    };
  }
  /**
   * Capture visible state for keys that will be affected by pending sync operations
   * This must be called BEFORE onTransactionStateChange clears optimistic state
   */
  capturePreSyncVisibleState() {
    if (this.pendingSyncedTransactions.length === 0) return;
    this.preSyncVisibleState.clear();
    const syncedKeys = /* @__PURE__ */ new Set();
    for (const transaction of this.pendingSyncedTransactions) {
      for (const operation of transaction.operations) {
        syncedKeys.add(operation.key);
      }
    }
    for (const key of syncedKeys) {
      this.recentlySyncedKeys.add(key);
    }
    for (const key of syncedKeys) {
      const currentValue = this.get(key);
      if (currentValue !== void 0) {
        this.preSyncVisibleState.set(key, currentValue);
      }
    }
  }
  /**
   * Trigger a recomputation when transactions change
   * This method should be called by the Transaction class when state changes
   */
  onTransactionStateChange() {
    this.shouldBatchEvents = this.pendingSyncedTransactions.length > 0;
    this.capturePreSyncVisibleState();
    this.recomputeOptimisticState(false);
  }
}
exports.CollectionImpl = CollectionImpl;
exports.createCollection = createCollection;
//# sourceMappingURL=collection.cjs.map
