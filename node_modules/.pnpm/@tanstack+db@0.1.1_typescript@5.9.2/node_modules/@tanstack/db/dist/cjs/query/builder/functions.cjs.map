{"version":3,"file":"functions.cjs","sources":["../../../../src/query/builder/functions.ts"],"sourcesContent":["import { Aggregate, Func } from \"../ir\"\nimport { toExpression } from \"./ref-proxy.js\"\nimport type { BasicExpression } from \"../ir\"\nimport type { RefProxy } from \"./ref-proxy.js\"\n\n// Helper type for any expression-like value\ntype ExpressionLike = BasicExpression | RefProxy<any> | any\n\n// Operators\n\nexport function eq<T>(\n  left: RefProxy<T>,\n  right: T | RefProxy<T> | BasicExpression<T>\n): BasicExpression<boolean>\nexport function eq<T extends string | number | boolean>(\n  left: T | BasicExpression<T>,\n  right: T | BasicExpression<T>\n): BasicExpression<boolean>\nexport function eq<T>(left: Aggregate<T>, right: any): BasicExpression<boolean>\nexport function eq(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`eq`, [toExpression(left), toExpression(right)])\n}\n\nexport function gt<T>(\n  left: RefProxy<T>,\n  right: T | RefProxy<T> | BasicExpression<T>\n): BasicExpression<boolean>\nexport function gt<T extends string | number>(\n  left: T | BasicExpression<T>,\n  right: T | BasicExpression<T>\n): BasicExpression<boolean>\nexport function gt<T>(left: Aggregate<T>, right: any): BasicExpression<boolean>\nexport function gt(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`gt`, [toExpression(left), toExpression(right)])\n}\n\nexport function gte<T>(\n  left: RefProxy<T>,\n  right: T | RefProxy<T> | BasicExpression<T>\n): BasicExpression<boolean>\nexport function gte<T extends string | number>(\n  left: T | BasicExpression<T>,\n  right: T | BasicExpression<T>\n): BasicExpression<boolean>\nexport function gte<T>(left: Aggregate<T>, right: any): BasicExpression<boolean>\nexport function gte(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`gte`, [toExpression(left), toExpression(right)])\n}\n\nexport function lt<T>(\n  left: RefProxy<T>,\n  right: T | RefProxy<T> | BasicExpression<T>\n): BasicExpression<boolean>\nexport function lt<T extends string | number>(\n  left: T | BasicExpression<T>,\n  right: T | BasicExpression<T>\n): BasicExpression<boolean>\nexport function lt<T>(left: Aggregate<T>, right: any): BasicExpression<boolean>\nexport function lt(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`lt`, [toExpression(left), toExpression(right)])\n}\n\nexport function lte<T>(\n  left: RefProxy<T>,\n  right: T | RefProxy<T> | BasicExpression<T>\n): BasicExpression<boolean>\nexport function lte<T extends string | number>(\n  left: T | BasicExpression<T>,\n  right: T | BasicExpression<T>\n): BasicExpression<boolean>\nexport function lte<T>(left: Aggregate<T>, right: any): BasicExpression<boolean>\nexport function lte(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`lte`, [toExpression(left), toExpression(right)])\n}\n\n// Overloads for and() - support 2 or more arguments\nexport function and(\n  left: ExpressionLike,\n  right: ExpressionLike\n): BasicExpression<boolean>\nexport function and(\n  left: ExpressionLike,\n  right: ExpressionLike,\n  ...rest: Array<ExpressionLike>\n): BasicExpression<boolean>\nexport function and(\n  left: ExpressionLike,\n  right: ExpressionLike,\n  ...rest: Array<ExpressionLike>\n): BasicExpression<boolean> {\n  const allArgs = [left, right, ...rest]\n  return new Func(\n    `and`,\n    allArgs.map((arg) => toExpression(arg))\n  )\n}\n\n// Overloads for or() - support 2 or more arguments\nexport function or(\n  left: ExpressionLike,\n  right: ExpressionLike\n): BasicExpression<boolean>\nexport function or(\n  left: ExpressionLike,\n  right: ExpressionLike,\n  ...rest: Array<ExpressionLike>\n): BasicExpression<boolean>\nexport function or(\n  left: ExpressionLike,\n  right: ExpressionLike,\n  ...rest: Array<ExpressionLike>\n): BasicExpression<boolean> {\n  const allArgs = [left, right, ...rest]\n  return new Func(\n    `or`,\n    allArgs.map((arg) => toExpression(arg))\n  )\n}\n\nexport function not(value: ExpressionLike): BasicExpression<boolean> {\n  return new Func(`not`, [toExpression(value)])\n}\n\nexport function inArray(\n  value: ExpressionLike,\n  array: ExpressionLike\n): BasicExpression<boolean> {\n  return new Func(`in`, [toExpression(value), toExpression(array)])\n}\n\nexport function like(\n  left:\n    | RefProxy<string>\n    | RefProxy<string | null>\n    | RefProxy<string | undefined>\n    | string\n    | BasicExpression<string>,\n  right: string | RefProxy<string> | BasicExpression<string>\n): BasicExpression<boolean>\nexport function like(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`like`, [toExpression(left), toExpression(right)])\n}\n\nexport function ilike(\n  left:\n    | RefProxy<string>\n    | RefProxy<string | null>\n    | RefProxy<string | undefined>\n    | string\n    | BasicExpression<string>,\n  right: string | RefProxy<string> | BasicExpression<string>\n): BasicExpression<boolean> {\n  return new Func(`ilike`, [toExpression(left), toExpression(right)])\n}\n\n// Functions\n\nexport function upper(\n  arg:\n    | RefProxy<string>\n    | RefProxy<string | undefined>\n    | string\n    | BasicExpression<string>\n): BasicExpression<string> {\n  return new Func(`upper`, [toExpression(arg)])\n}\n\nexport function lower(\n  arg:\n    | RefProxy<string>\n    | RefProxy<string | undefined>\n    | string\n    | BasicExpression<string>\n): BasicExpression<string> {\n  return new Func(`lower`, [toExpression(arg)])\n}\n\nexport function length(\n  arg:\n    | RefProxy<string>\n    | RefProxy<string | undefined>\n    | RefProxy<Array<any>>\n    | RefProxy<Array<any> | undefined>\n    | string\n    | Array<any>\n    | BasicExpression<string>\n    | BasicExpression<Array<any>>\n): BasicExpression<number> {\n  return new Func(`length`, [toExpression(arg)])\n}\n\nexport function concat(\n  ...args: Array<ExpressionLike>\n): BasicExpression<string> {\n  return new Func(\n    `concat`,\n    args.map((arg) => toExpression(arg))\n  )\n}\n\nexport function coalesce(...args: Array<ExpressionLike>): BasicExpression<any> {\n  return new Func(\n    `coalesce`,\n    args.map((arg) => toExpression(arg))\n  )\n}\n\nexport function add(\n  left:\n    | RefProxy<number>\n    | RefProxy<number | undefined>\n    | number\n    | BasicExpression<number>,\n  right:\n    | RefProxy<number>\n    | RefProxy<number | undefined>\n    | number\n    | BasicExpression<number>\n): BasicExpression<number> {\n  return new Func(`add`, [toExpression(left), toExpression(right)])\n}\n\n// Aggregates\n\nexport function count(arg: ExpressionLike): Aggregate<number> {\n  return new Aggregate(`count`, [toExpression(arg)])\n}\n\nexport function avg(\n  arg:\n    | RefProxy<number>\n    | RefProxy<number | undefined>\n    | number\n    | BasicExpression<number>\n): Aggregate<number> {\n  return new Aggregate(`avg`, [toExpression(arg)])\n}\n\nexport function sum(\n  arg:\n    | RefProxy<number>\n    | RefProxy<number | undefined>\n    | number\n    | BasicExpression<number>\n): Aggregate<number> {\n  return new Aggregate(`sum`, [toExpression(arg)])\n}\n\nexport function min(\n  arg:\n    | RefProxy<number>\n    | RefProxy<number | undefined>\n    | number\n    | BasicExpression<number>\n): Aggregate<number> {\n  return new Aggregate(`min`, [toExpression(arg)])\n}\n\nexport function max(\n  arg:\n    | RefProxy<number>\n    | RefProxy<number | undefined>\n    | number\n    | BasicExpression<number>\n): Aggregate<number> {\n  return new Aggregate(`max`, [toExpression(arg)])\n}\n\n/**\n * List of comparison function names that can be used with indexes\n */\nexport const comparisonFunctions = [\n  `eq`,\n  `gt`,\n  `gte`,\n  `lt`,\n  `lte`,\n  `in`,\n  `like`,\n  `ilike`,\n] as const\n"],"names":["Func","toExpression","Aggregate"],"mappings":"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"}