"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const ir = require("../ir.cjs");
const SUPPORTED_COLLECTION_FUNCS = /* @__PURE__ */ new Set([
  `eq`,
  `gt`,
  `lt`,
  `gte`,
  `lte`,
  `and`,
  `or`,
  `in`
]);
function isConvertibleToCollectionFilter(whereClause) {
  const tpe = whereClause.type;
  if (tpe === `func`) {
    if (!SUPPORTED_COLLECTION_FUNCS.has(whereClause.name)) {
      return false;
    }
    return whereClause.args.every(
      (arg) => isConvertibleToCollectionFilter(arg)
    );
  }
  return [`val`, `ref`].includes(tpe);
}
function convertToBasicExpression(whereClause, collectionAlias) {
  const tpe = whereClause.type;
  if (tpe === `val`) {
    return new ir.Value(whereClause.value);
  } else if (tpe === `ref`) {
    const path = whereClause.path;
    if (Array.isArray(path)) {
      if (path[0] === collectionAlias && path.length > 1) {
        return new ir.PropRef(path.slice(1));
      } else if (path.length === 1 && path[0] !== void 0) {
        return new ir.PropRef([path[0]]);
      }
    }
    return new ir.PropRef(Array.isArray(path) ? path : [String(path)]);
  } else {
    if (!SUPPORTED_COLLECTION_FUNCS.has(whereClause.name)) {
      return null;
    }
    const args = [];
    for (const arg of whereClause.args) {
      const convertedArg = convertToBasicExpression(
        arg,
        collectionAlias
      );
      if (convertedArg == null) {
        return null;
      }
      args.push(convertedArg);
    }
    return new ir.Func(whereClause.name, args);
  }
}
exports.SUPPORTED_COLLECTION_FUNCS = SUPPORTED_COLLECTION_FUNCS;
exports.convertToBasicExpression = convertToBasicExpression;
exports.isConvertibleToCollectionFilter = isConvertibleToCollectionFilter;
//# sourceMappingURL=expressions.cjs.map
