{"version":3,"file":"proxy.js","sources":["../../src/proxy.ts"],"sourcesContent":["/**\n * A utility for creating a proxy that captures changes to an object\n * and provides a way to retrieve those changes.\n */\n\n/**\n * Simple debug utility that only logs when debug mode is enabled\n * Set DEBUG to true in localStorage to enable debug logging\n */\nfunction debugLog(...args: Array<unknown>): void {\n  // Check if we're in a browser environment\n  const isBrowser =\n    typeof window !== `undefined` && typeof localStorage !== `undefined`\n\n  // In browser, check localStorage for debug flag\n  if (isBrowser && localStorage.getItem(`DEBUG`) === `true`) {\n    console.log(`[proxy]`, ...args)\n  }\n  // In Node.js environment, check for environment variable (though this is primarily for browser)\n  else if (\n    // true\n    !isBrowser &&\n    typeof process !== `undefined` &&\n    process.env.DEBUG === `true`\n  ) {\n    console.log(`[proxy]`, ...args)\n  }\n}\n\n// Add TypedArray interface with proper type\ninterface TypedArray {\n  length: number\n  [index: number]: number\n}\n\n// Update type for ChangeTracker\ninterface ChangeTracker<T extends object> {\n  originalObject: T\n  modified: boolean\n  copy_: T\n  proxyCount: number\n  assigned_: Record<string | symbol, boolean>\n  parent?:\n    | {\n        tracker: ChangeTracker<Record<string | symbol, unknown>>\n        prop: string | symbol\n      }\n    | {\n        tracker: ChangeTracker<Record<string | symbol, unknown>>\n        prop: string | symbol\n        updateMap: (newValue: unknown) => void\n      }\n    | {\n        tracker: ChangeTracker<Record<string | symbol, unknown>>\n        prop: unknown\n        updateSet: (newValue: unknown) => void\n      }\n  target: T\n}\n\n/**\n * Deep clones an object while preserving special types like Date and RegExp\n */\n\nfunction deepClone<T extends unknown>(\n  obj: T,\n  visited = new WeakMap<object, unknown>()\n): T {\n  // Handle null and undefined\n  if (obj === null || obj === undefined) {\n    return obj\n  }\n\n  // Handle primitive types\n  if (typeof obj !== `object`) {\n    return obj\n  }\n\n  // If we've already cloned this object, return the cached clone\n  if (visited.has(obj as object)) {\n    return visited.get(obj as object) as T\n  }\n\n  if (obj instanceof Date) {\n    return new Date(obj.getTime()) as unknown as T\n  }\n\n  if (obj instanceof RegExp) {\n    return new RegExp(obj.source, obj.flags) as unknown as T\n  }\n\n  if (Array.isArray(obj)) {\n    const arrayClone = [] as Array<unknown>\n    visited.set(obj as object, arrayClone)\n    obj.forEach((item, index) => {\n      arrayClone[index] = deepClone(item, visited)\n    })\n    return arrayClone as unknown as T\n  }\n\n  // Handle TypedArrays\n  if (ArrayBuffer.isView(obj) && !(obj instanceof DataView)) {\n    // Get the constructor to create a new instance of the same type\n    const TypedArrayConstructor = Object.getPrototypeOf(obj).constructor\n    const clone = new TypedArrayConstructor(\n      (obj as unknown as TypedArray).length\n    ) as unknown as TypedArray\n    visited.set(obj as object, clone)\n\n    // Copy the values\n    for (let i = 0; i < (obj as unknown as TypedArray).length; i++) {\n      clone[i] = (obj as unknown as TypedArray)[i]!\n    }\n\n    return clone as unknown as T\n  }\n\n  if (obj instanceof Map) {\n    const clone = new Map() as Map<unknown, unknown>\n    visited.set(obj as object, clone)\n    obj.forEach((value, key) => {\n      clone.set(key, deepClone(value, visited))\n    })\n    return clone as unknown as T\n  }\n\n  if (obj instanceof Set) {\n    const clone = new Set()\n    visited.set(obj as object, clone)\n    obj.forEach((value) => {\n      clone.add(deepClone(value, visited))\n    })\n    return clone as unknown as T\n  }\n\n  const clone = {} as Record<string | symbol, unknown>\n  visited.set(obj as object, clone)\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      clone[key] = deepClone(\n        (obj as Record<string | symbol, unknown>)[key],\n        visited\n      )\n    }\n  }\n\n  const symbolProps = Object.getOwnPropertySymbols(obj)\n  for (const sym of symbolProps) {\n    clone[sym] = deepClone(\n      (obj as Record<string | symbol, unknown>)[sym],\n      visited\n    )\n  }\n\n  return clone as T\n}\n\n/**\n * Deep equality check that handles special types like Date, RegExp, Map, and Set\n */\nfunction deepEqual<T>(a: T, b: T): boolean {\n  // Handle primitive types\n  if (a === b) return true\n\n  // If either is null or not an object, they're not equal\n  if (\n    a === null ||\n    b === null ||\n    typeof a !== `object` ||\n    typeof b !== `object`\n  ) {\n    return false\n  }\n\n  // Handle Date objects\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime()\n  }\n\n  // Handle RegExp objects\n  if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source && a.flags === b.flags\n  }\n\n  // Handle Map objects\n  if (a instanceof Map && b instanceof Map) {\n    if (a.size !== b.size) return false\n\n    const entries = Array.from(a.entries())\n    for (const [key, val] of entries) {\n      if (!b.has(key) || !deepEqual(val, b.get(key))) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  // Handle Set objects\n  if (a instanceof Set && b instanceof Set) {\n    if (a.size !== b.size) return false\n\n    // Convert to arrays for comparison\n    const aValues = Array.from(a)\n    const bValues = Array.from(b)\n\n    // Simple comparison for primitive values\n    if (aValues.every((val) => typeof val !== `object`)) {\n      return aValues.every((val) => b.has(val))\n    }\n\n    // For objects in sets, we need to do a more complex comparison\n    // This is a simplified approach and may not work for all cases\n    return aValues.length === bValues.length\n  }\n\n  // Handle arrays\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false\n\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false\n    }\n\n    return true\n  }\n\n  // Handle TypedArrays\n  if (\n    ArrayBuffer.isView(a) &&\n    ArrayBuffer.isView(b) &&\n    !(a instanceof DataView) &&\n    !(b instanceof DataView)\n  ) {\n    const typedA = a as unknown as TypedArray\n    const typedB = b as unknown as TypedArray\n    if (typedA.length !== typedB.length) return false\n\n    for (let i = 0; i < typedA.length; i++) {\n      if (typedA[i] !== typedB[i]) return false\n    }\n\n    return true\n  }\n\n  // Handle plain objects\n  const keysA = Object.keys(a as object)\n  const keysB = Object.keys(b as object)\n\n  if (keysA.length !== keysB.length) return false\n\n  return keysA.every(\n    (key) =>\n      Object.prototype.hasOwnProperty.call(b, key) &&\n      deepEqual((a as any)[key], (b as any)[key])\n  )\n}\n\nlet count = 0\nfunction getProxyCount() {\n  count += 1\n  return count\n}\n\n/**\n * Creates a proxy that tracks changes to the target object\n *\n * @param target The object to proxy\n * @param parent Optional parent information\n * @returns An object containing the proxy and a function to get the changes\n */\nexport function createChangeProxy<\n  T extends Record<string | symbol, any | undefined>,\n>(\n  target: T,\n  parent?: {\n    tracker: ChangeTracker<Record<string | symbol, unknown>>\n    prop: string | symbol\n  }\n): {\n  proxy: T\n\n  getChanges: () => Record<string | symbol, any>\n} {\n  const changeProxyCache = new Map<object, object>()\n\n  function memoizedCreateChangeProxy<\n    TInner extends Record<string | symbol, any | undefined>,\n  >(\n    innerTarget: TInner,\n    innerParent?: {\n      tracker: ChangeTracker<Record<string | symbol, unknown>>\n      prop: string | symbol\n    }\n  ): {\n    proxy: TInner\n    getChanges: () => Record<string | symbol, any>\n  } {\n    debugLog(`Object ID:`, innerTarget.constructor.name)\n    if (changeProxyCache.has(innerTarget)) {\n      return changeProxyCache.get(innerTarget) as {\n        proxy: TInner\n        getChanges: () => Record<string | symbol, any>\n      }\n    } else {\n      const changeProxy = createChangeProxy(innerTarget, innerParent)\n      changeProxyCache.set(innerTarget, changeProxy)\n      return changeProxy\n    }\n  }\n  // Create a WeakMap to cache proxies for nested objects\n  // This prevents creating multiple proxies for the same object\n  // and handles circular references\n  const proxyCache = new Map<object, object>()\n\n  // Create a change tracker to track changes to the object\n  const changeTracker: ChangeTracker<T> = {\n    copy_: deepClone(target),\n    originalObject: deepClone(target),\n    proxyCount: getProxyCount(),\n    modified: false,\n    assigned_: {},\n    parent,\n    target, // Store reference to the target object\n  }\n\n  debugLog(\n    `createChangeProxy called for target`,\n    target,\n    changeTracker.proxyCount\n  )\n  // Mark this object and all its ancestors as modified\n  // Also propagate the actual changes up the chain\n  function markChanged(state: ChangeTracker<object>) {\n    if (!state.modified) {\n      state.modified = true\n    }\n\n    // Propagate the change up the parent chain\n    if (state.parent) {\n      debugLog(`propagating change to parent`)\n\n      // Check if this is a special Map parent with updateMap function\n      if (`updateMap` in state.parent) {\n        // Use the special updateMap function for Maps\n        state.parent.updateMap(state.copy_)\n      } else if (`updateSet` in state.parent) {\n        // Use the special updateSet function for Sets\n        state.parent.updateSet(state.copy_)\n      } else {\n        // Update parent's copy with this object's current state\n        state.parent.tracker.copy_[state.parent.prop] = state.copy_\n        state.parent.tracker.assigned_[state.parent.prop] = true\n      }\n\n      // Mark parent as changed\n      markChanged(state.parent.tracker)\n    }\n  }\n\n  // Check if all properties in the current state have reverted to original values\n  function checkIfReverted(\n    state: ChangeTracker<Record<string | symbol, unknown>>\n  ): boolean {\n    debugLog(\n      `checkIfReverted called with assigned keys:`,\n      Object.keys(state.assigned_)\n    )\n\n    // If there are no assigned properties, object is unchanged\n    if (\n      Object.keys(state.assigned_).length === 0 &&\n      Object.getOwnPropertySymbols(state.assigned_).length === 0\n    ) {\n      debugLog(`No assigned properties, returning true`)\n      return true\n    }\n\n    // Check each assigned regular property\n    for (const prop in state.assigned_) {\n      // If this property is marked as assigned\n      if (state.assigned_[prop] === true) {\n        const currentValue = state.copy_[prop]\n        const originalValue = (state.originalObject as any)[prop]\n\n        debugLog(\n          `Checking property ${String(prop)}, current:`,\n          currentValue,\n          `original:`,\n          originalValue\n        )\n\n        // If the value is not equal to original, something is still changed\n        if (!deepEqual(currentValue, originalValue)) {\n          debugLog(`Property ${String(prop)} is different, returning false`)\n          return false\n        }\n      } else if (state.assigned_[prop] === false) {\n        // Property was deleted, so it's different from original\n        debugLog(`Property ${String(prop)} was deleted, returning false`)\n        return false\n      }\n    }\n\n    // Check each assigned symbol property\n    const symbolProps = Object.getOwnPropertySymbols(state.assigned_)\n    for (const sym of symbolProps) {\n      if (state.assigned_[sym] === true) {\n        const currentValue = (state.copy_ as any)[sym]\n        const originalValue = (state.originalObject as any)[sym]\n\n        // If the value is not equal to original, something is still changed\n        if (!deepEqual(currentValue, originalValue)) {\n          debugLog(`Symbol property is different, returning false`)\n          return false\n        }\n      } else if (state.assigned_[sym] === false) {\n        // Property was deleted, so it's different from original\n        debugLog(`Symbol property was deleted, returning false`)\n        return false\n      }\n    }\n\n    debugLog(`All properties match original values, returning true`)\n    // All assigned properties match their original values\n    return true\n  }\n\n  // Update parent status based on child changes\n  function checkParentStatus(\n    parentState: ChangeTracker<Record<string | symbol, unknown>>,\n    childProp: string | symbol | unknown\n  ) {\n    debugLog(`checkParentStatus called for child prop:`, childProp)\n\n    // Check if all properties of the parent are reverted\n    const isReverted = checkIfReverted(parentState)\n    debugLog(`Parent checkIfReverted returned:`, isReverted)\n\n    if (isReverted) {\n      debugLog(`Parent is fully reverted, clearing tracking`)\n      // If everything is reverted, clear the tracking\n      parentState.modified = false\n      parentState.assigned_ = {}\n\n      // Continue up the chain\n      if (parentState.parent) {\n        debugLog(`Continuing up the parent chain`)\n        checkParentStatus(parentState.parent.tracker, parentState.parent.prop)\n      }\n    }\n  }\n\n  // Create a proxy for the target object\n  function createObjectProxy<TObj extends object>(obj: TObj): TObj {\n    debugLog(`createObjectProxy`, obj)\n    // If we've already created a proxy for this object, return it\n    if (proxyCache.has(obj)) {\n      debugLog(`proxyCache found match`)\n      return proxyCache.get(obj) as TObj\n    }\n\n    // Create a proxy for the object\n    const proxy = new Proxy(obj, {\n      get(ptarget, prop) {\n        debugLog(`get`, ptarget, prop)\n        const value =\n          changeTracker.copy_[prop as keyof T] ??\n          changeTracker.originalObject[prop as keyof T]\n\n        const originalValue = changeTracker.originalObject[prop as keyof T]\n\n        debugLog(`value (at top of proxy get)`, value)\n\n        // If it's a getter, return the value directly\n        const desc = Object.getOwnPropertyDescriptor(ptarget, prop)\n        if (desc?.get) {\n          return value\n        }\n\n        // If the value is a function, bind it to the ptarget\n        if (typeof value === `function`) {\n          // For Array methods that modify the array\n          if (Array.isArray(ptarget)) {\n            const methodName = prop.toString()\n            const modifyingMethods = new Set([\n              `pop`,\n              `push`,\n              `shift`,\n              `unshift`,\n              `splice`,\n              `sort`,\n              `reverse`,\n              `fill`,\n              `copyWithin`,\n            ])\n\n            if (modifyingMethods.has(methodName)) {\n              return function (...args: Array<unknown>) {\n                const result = value.apply(changeTracker.copy_, args)\n                markChanged(changeTracker)\n                return result\n              }\n            }\n          }\n\n          // For Map and Set methods that modify the collection\n          if (ptarget instanceof Map || ptarget instanceof Set) {\n            const methodName = prop.toString()\n            const modifyingMethods = new Set([\n              `set`,\n              `delete`,\n              `clear`,\n              `add`,\n              `pop`,\n              `push`,\n              `shift`,\n              `unshift`,\n              `splice`,\n              `sort`,\n              `reverse`,\n            ])\n\n            if (modifyingMethods.has(methodName)) {\n              return function (...args: Array<unknown>) {\n                const result = value.apply(changeTracker.copy_, args)\n                markChanged(changeTracker)\n                return result\n              }\n            }\n\n            // Handle iterator methods for Map and Set\n            const iteratorMethods = new Set([\n              `entries`,\n              `keys`,\n              `values`,\n              `forEach`,\n              Symbol.iterator,\n            ])\n\n            if (iteratorMethods.has(methodName) || prop === Symbol.iterator) {\n              return function (this: unknown, ...args: Array<unknown>) {\n                const result = value.apply(changeTracker.copy_, args)\n\n                // For forEach, we need to wrap the callback to track changes\n                if (methodName === `forEach`) {\n                  const callback = args[0]\n                  if (typeof callback === `function`) {\n                    // Replace the original callback with our wrapped version\n                    const wrappedCallback = function (\n                      this: unknown,\n                      // eslint-disable-next-line\n                      value: unknown,\n                      key: unknown,\n                      collection: unknown\n                    ) {\n                      // Call the original callback\n                      const cbresult = callback.call(\n                        this,\n                        value,\n                        key,\n                        collection\n                      )\n                      // Mark as changed since the callback might have modified the value\n                      markChanged(changeTracker)\n                      return cbresult\n                    }\n                    // Call forEach with our wrapped callback\n                    return value.apply(ptarget, [\n                      wrappedCallback,\n                      ...args.slice(1),\n                    ])\n                  }\n                }\n\n                // For iterators (entries, keys, values, Symbol.iterator)\n                if (\n                  methodName === `entries` ||\n                  methodName === `values` ||\n                  methodName === Symbol.iterator.toString() ||\n                  prop === Symbol.iterator\n                ) {\n                  // If it's an iterator, we need to wrap the returned iterator\n                  // to track changes when the values are accessed and potentially modified\n                  const originalIterator = result\n\n                  // For values() iterator on Maps, we need to create a value-to-key mapping\n                  const valueToKeyMap = new Map()\n                  if (methodName === `values` && ptarget instanceof Map) {\n                    // Build a mapping from value to key for reverse lookup\n                    // Use the copy_ (which is the current state) to build the mapping\n                    for (const [\n                      key,\n                      mapValue,\n                    ] of changeTracker.copy_.entries()) {\n                      valueToKeyMap.set(mapValue, key)\n                    }\n                  }\n\n                  // For Set iterators, we need to create an original-to-modified mapping\n                  const originalToModifiedMap = new Map()\n                  if (ptarget instanceof Set) {\n                    // Initialize with original values\n                    for (const setValue of changeTracker.copy_.values()) {\n                      originalToModifiedMap.set(setValue, setValue)\n                    }\n                  }\n\n                  // Create a proxy for the iterator that will mark changes when next() is called\n                  return {\n                    next() {\n                      const nextResult = originalIterator.next()\n\n                      // If we have a value and it's an object, we need to track it\n                      if (\n                        !nextResult.done &&\n                        nextResult.value &&\n                        typeof nextResult.value === `object`\n                      ) {\n                        // For entries, the value is a [key, value] pair\n                        if (\n                          methodName === `entries` &&\n                          Array.isArray(nextResult.value) &&\n                          nextResult.value.length === 2\n                        ) {\n                          // The value is at index 1 in the [key, value] pair\n                          if (\n                            nextResult.value[1] &&\n                            typeof nextResult.value[1] === `object`\n                          ) {\n                            const mapKey = nextResult.value[0]\n                            // Create a special parent tracker that knows how to update the Map\n                            const mapParent = {\n                              tracker: changeTracker,\n                              prop: mapKey,\n                              updateMap: (newValue: unknown) => {\n                                // Update the Map in the copy\n                                if (changeTracker.copy_ instanceof Map) {\n                                  changeTracker.copy_.set(mapKey, newValue)\n                                }\n                              },\n                            }\n\n                            // Create a proxy for the value and replace it in the result\n                            const { proxy: valueProxy } =\n                              memoizedCreateChangeProxy(\n                                nextResult.value[1],\n                                mapParent\n                              )\n                            nextResult.value[1] = valueProxy\n                          }\n                        } else if (\n                          methodName === `values` ||\n                          methodName === Symbol.iterator.toString() ||\n                          prop === Symbol.iterator\n                        ) {\n                          // If the value is an object, create a proxy for it\n                          if (\n                            typeof nextResult.value === `object` &&\n                            nextResult.value !== null\n                          ) {\n                            // For Map values(), try to find the key using our mapping\n                            if (\n                              methodName === `values` &&\n                              ptarget instanceof Map\n                            ) {\n                              const mapKey = valueToKeyMap.get(nextResult.value)\n                              if (mapKey !== undefined) {\n                                // Create a special parent tracker for this Map value\n                                const mapParent = {\n                                  tracker: changeTracker,\n                                  prop: mapKey,\n                                  updateMap: (newValue: unknown) => {\n                                    // Update the Map in the copy\n                                    if (changeTracker.copy_ instanceof Map) {\n                                      changeTracker.copy_.set(mapKey, newValue)\n                                    }\n                                  },\n                                }\n\n                                const { proxy: valueProxy } =\n                                  memoizedCreateChangeProxy(\n                                    nextResult.value,\n                                    mapParent\n                                  )\n                                nextResult.value = valueProxy\n                              }\n                            } else if (ptarget instanceof Set) {\n                              // For Set, we need to track modifications and update the Set accordingly\n                              const setOriginalValue = nextResult.value\n                              const setParent = {\n                                tracker: changeTracker,\n                                prop: setOriginalValue, // Use the original value as the prop\n                                updateSet: (newValue: unknown) => {\n                                  // Update the Set in the copy by removing old value and adding new one\n                                  if (changeTracker.copy_ instanceof Set) {\n                                    changeTracker.copy_.delete(setOriginalValue)\n                                    changeTracker.copy_.add(newValue)\n                                    // Update our mapping for future iterations\n                                    originalToModifiedMap.set(\n                                      setOriginalValue,\n                                      newValue\n                                    )\n                                  }\n                                },\n                              }\n\n                              const { proxy: valueProxy } =\n                                memoizedCreateChangeProxy(\n                                  nextResult.value,\n                                  setParent\n                                )\n                              nextResult.value = valueProxy\n                            } else {\n                              // For other cases, use a symbol as a placeholder\n                              const tempKey = Symbol(`iterator-value`)\n                              const { proxy: valueProxy } =\n                                memoizedCreateChangeProxy(nextResult.value, {\n                                  tracker: changeTracker,\n                                  prop: tempKey,\n                                })\n                              nextResult.value = valueProxy\n                            }\n                          }\n                        }\n                      }\n\n                      return nextResult\n                    },\n                    [Symbol.iterator]() {\n                      return this\n                    },\n                  }\n                }\n\n                return result\n              }\n            }\n          }\n          return value.bind(ptarget)\n        }\n\n        // If the value is an object, create a proxy for it\n        if (\n          value &&\n          typeof value === `object` &&\n          !((value as any) instanceof Date) &&\n          !((value as any) instanceof RegExp)\n        ) {\n          // Create a parent reference for the nested object\n          const nestedParent = {\n            tracker: changeTracker,\n            prop: String(prop),\n          }\n\n          // Create a proxy for the nested object\n          const { proxy: nestedProxy } = memoizedCreateChangeProxy(\n            originalValue,\n            nestedParent\n          )\n\n          // Cache the proxy\n          proxyCache.set(value, nestedProxy)\n\n          return nestedProxy\n        }\n\n        return value\n      },\n\n      set(_sobj, prop, value) {\n        const currentValue = changeTracker.copy_[prop as keyof T]\n        debugLog(\n          `set called for property ${String(prop)}, current:`,\n          currentValue,\n          `new:`,\n          value\n        )\n\n        // Only track the change if the value is actually different\n        if (!deepEqual(currentValue, value)) {\n          // Check if the new value is equal to the original value\n          // Important: Use the originalObject to get the true original value\n          const originalValue = changeTracker.originalObject[prop as keyof T]\n          const isRevertToOriginal = deepEqual(value, originalValue)\n          debugLog(\n            `value:`,\n            value,\n            `original:`,\n            originalValue,\n            `isRevertToOriginal:`,\n            isRevertToOriginal\n          )\n\n          if (isRevertToOriginal) {\n            debugLog(`Reverting property ${String(prop)} to original value`)\n            // If the value is reverted to its original state, remove it from changes\n            delete changeTracker.assigned_[prop.toString()]\n\n            // Make sure the copy is updated with the original value\n            debugLog(`Updating copy with original value for ${String(prop)}`)\n            changeTracker.copy_[prop as keyof T] = deepClone(originalValue)\n\n            // Check if all properties in this object have been reverted\n            debugLog(`Checking if all properties reverted`)\n            const allReverted = checkIfReverted(changeTracker)\n            debugLog(`All reverted:`, allReverted)\n\n            if (allReverted) {\n              debugLog(`All properties reverted, clearing tracking`)\n              // If all have been reverted, clear tracking\n              changeTracker.modified = false\n              changeTracker.assigned_ = {}\n\n              // If we're a nested object, check if the parent needs updating\n              if (parent) {\n                debugLog(`Updating parent for property:`, parent.prop)\n                checkParentStatus(parent.tracker, parent.prop)\n              }\n            } else {\n              // Some properties are still changed\n              debugLog(`Some properties still changed, keeping modified flag`)\n              changeTracker.modified = true\n            }\n          } else {\n            debugLog(`Setting new value for property ${String(prop)}`)\n\n            // Set the value on the copy\n            changeTracker.copy_[prop as keyof T] = value\n\n            // Track that this property was assigned - store using the actual property (symbol or string)\n            changeTracker.assigned_[prop.toString()] = true\n\n            // Mark this object and its ancestors as modified\n            debugLog(`Marking object and ancestors as modified`, changeTracker)\n            markChanged(changeTracker)\n          }\n        } else {\n          debugLog(`Value unchanged, not tracking`)\n        }\n\n        return true\n      },\n\n      defineProperty(_ptarget, prop, descriptor) {\n        // const result = Reflect.defineProperty(\n        //   changeTracker.copy_,\n        //   prop,\n        //   descriptor\n        // )\n        // if (result) {\n        if (`value` in descriptor) {\n          changeTracker.copy_[prop as keyof T] = deepClone(descriptor.value)\n          changeTracker.assigned_[prop.toString()] = true\n          markChanged(changeTracker)\n        }\n        // }\n        // return result\n        return true\n      },\n\n      deleteProperty(dobj, prop) {\n        debugLog(`deleteProperty`, dobj, prop)\n        const stringProp = typeof prop === `symbol` ? prop.toString() : prop\n\n        if (stringProp in dobj) {\n          // Check if the property exists in the original object\n          const hadPropertyInOriginal =\n            stringProp in changeTracker.originalObject\n\n          // Delete the property from the copy\n          // Use type assertion to tell TypeScript this is allowed\n          delete (changeTracker.copy_ as Record<string | symbol, unknown>)[prop]\n\n          // If the property didn't exist in the original object, removing it\n          // should revert to the original state\n          if (!hadPropertyInOriginal) {\n            delete changeTracker.copy_[stringProp]\n            delete changeTracker.assigned_[stringProp]\n\n            // If this is the last change and we're not a nested object,\n            // mark the object as unmodified\n            if (\n              Object.keys(changeTracker.assigned_).length === 0 &&\n              Object.getOwnPropertySymbols(changeTracker.assigned_).length === 0\n            ) {\n              changeTracker.modified = false\n            } else {\n              // We still have changes, keep as modified\n              changeTracker.modified = true\n            }\n          } else {\n            // Mark this property as deleted\n            changeTracker.assigned_[stringProp] = false\n            changeTracker.copy_[stringProp as keyof T] = undefined as T[keyof T]\n            markChanged(changeTracker)\n          }\n        }\n\n        return true\n      },\n    })\n\n    // Cache the proxy\n    proxyCache.set(obj, proxy)\n\n    return proxy\n  }\n\n  // Create a proxy for the target object\n  const proxy = createObjectProxy(target)\n\n  // Return the proxy and a function to get the changes\n  return {\n    proxy,\n    getChanges: () => {\n      debugLog(`getChanges called, modified:`, changeTracker.modified)\n      debugLog(changeTracker)\n\n      // First, check if the object is still considered modified\n      if (!changeTracker.modified) {\n        debugLog(`Object not modified, returning empty object`)\n        return {}\n      }\n\n      // If we have a copy, return it directly\n      // Check if valueObj is actually an object\n      if (\n        typeof changeTracker.copy_ !== `object` ||\n        Array.isArray(changeTracker.copy_)\n      ) {\n        return changeTracker.copy_\n      }\n\n      if (Object.keys(changeTracker.assigned_).length === 0) {\n        return changeTracker.copy_\n      }\n\n      const result: Record<string, any | undefined> = {}\n\n      // Iterate through keys in keyObj\n      for (const key in changeTracker.copy_) {\n        // If the key's value is true and the key exists in valueObj\n        if (\n          changeTracker.assigned_[key] === true &&\n          key in changeTracker.copy_\n        ) {\n          result[key] = changeTracker.copy_[key]\n        }\n      }\n      debugLog(`Returning copy:`, result)\n      return result as unknown as Record<string | symbol, unknown>\n    },\n  }\n}\n\n/**\n * Creates proxies for an array of objects and tracks changes to each\n *\n * @param targets Array of objects to proxy\n * @returns An object containing the array of proxies and a function to get all changes\n */\nexport function createArrayChangeProxy<T extends object>(\n  targets: Array<T>\n): {\n  proxies: Array<T>\n  getChanges: () => Array<Record<string | symbol, unknown>>\n} {\n  const proxiesWithChanges = targets.map((target) => createChangeProxy(target))\n\n  return {\n    proxies: proxiesWithChanges.map((p) => p.proxy),\n    getChanges: () => proxiesWithChanges.map((p) => p.getChanges()),\n  }\n}\n\n/**\n * Creates a proxy for an object, passes it to a callback function,\n * and returns the changes made by the callback\n *\n * @param target The object to proxy\n * @param callback Function that receives the proxy and can make changes to it\n * @returns The changes made to the object\n */\nexport function withChangeTracking<T extends object>(\n  target: T,\n  callback: (proxy: T) => void\n): Record<string | symbol, unknown> {\n  const { proxy, getChanges } = createChangeProxy(target)\n\n  callback(proxy)\n\n  return getChanges()\n}\n\n/**\n * Creates proxies for an array of objects, passes them to a callback function,\n * and returns the changes made by the callback for each object\n *\n * @param targets Array of objects to proxy\n * @param callback Function that receives the proxies and can make changes to them\n * @returns Array of changes made to each object\n */\nexport function withArrayChangeTracking<T extends object>(\n  targets: Array<T>,\n  callback: (proxies: Array<T>) => void\n): Array<Record<string | symbol, unknown>> {\n  const { proxies, getChanges } = createArrayChangeProxy(targets)\n\n  callback(proxies)\n\n  return getChanges()\n}\n"],"names":["clone","proxy","value"],"mappings":"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"}