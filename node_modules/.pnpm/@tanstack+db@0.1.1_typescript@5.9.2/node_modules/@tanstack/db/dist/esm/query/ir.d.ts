import { CollectionImpl } from '../collection.js';
import { NamespacedRow } from '../types.js';
export interface QueryIR {
    from: From;
    select?: Select;
    join?: Join;
    where?: Array<Where>;
    groupBy?: GroupBy;
    having?: Array<Having>;
    orderBy?: OrderBy;
    limit?: Limit;
    offset?: Offset;
    distinct?: true;
    fnSelect?: (row: NamespacedRow) => any;
    fnWhere?: Array<(row: NamespacedRow) => any>;
    fnHaving?: Array<(row: NamespacedRow) => any>;
}
export type From = CollectionRef | QueryRef;
export type Select = {
    [alias: string]: BasicExpression | Aggregate;
};
export type Join = Array<JoinClause>;
export interface JoinClause {
    from: CollectionRef | QueryRef;
    type: `left` | `right` | `inner` | `outer` | `full` | `cross`;
    left: BasicExpression;
    right: BasicExpression;
}
export type Where = BasicExpression<boolean>;
export type GroupBy = Array<BasicExpression>;
export type Having = Where;
export type OrderBy = Array<OrderByClause>;
export type OrderByClause = {
    expression: BasicExpression;
    direction: OrderByDirection;
};
export type OrderByDirection = `asc` | `desc`;
export type Limit = number;
export type Offset = number;
declare abstract class BaseExpression<T = any> {
    abstract type: string;
    /** @internal - Type brand for TypeScript inference */
    readonly __returnType: T;
}
export declare class CollectionRef extends BaseExpression {
    collection: CollectionImpl;
    alias: string;
    type: "collectionRef";
    constructor(collection: CollectionImpl, alias: string);
}
export declare class QueryRef extends BaseExpression {
    query: QueryIR;
    alias: string;
    type: "queryRef";
    constructor(query: QueryIR, alias: string);
}
export declare class PropRef<T = any> extends BaseExpression<T> {
    path: Array<string>;
    type: "ref";
    constructor(path: Array<string>);
}
export declare class Value<T = any> extends BaseExpression<T> {
    value: T;
    type: "val";
    constructor(value: T);
}
export declare class Func<T = any> extends BaseExpression<T> {
    name: string;
    args: Array<BasicExpression>;
    type: "func";
    constructor(name: string, // such as eq, gt, lt, upper, lower, etc.
    args: Array<BasicExpression>);
}
export type BasicExpression<T = any> = PropRef<T> | Value<T> | Func<T>;
export declare class Aggregate<T = any> extends BaseExpression<T> {
    name: string;
    args: Array<BasicExpression>;
    type: "agg";
    constructor(name: string, // such as count, avg, sum, min, max, etc.
    args: Array<BasicExpression>);
}
export {};
