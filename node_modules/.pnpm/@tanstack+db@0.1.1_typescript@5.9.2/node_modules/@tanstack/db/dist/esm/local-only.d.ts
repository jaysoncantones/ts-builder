import { CollectionConfig, DeleteMutationFnParams, InsertMutationFnParams, ResolveType, UpdateMutationFnParams, UtilsRecord } from './types.js';
import { StandardSchemaV1 } from '@standard-schema/spec';
/**
 * Configuration interface for Local-only collection options
 * @template TExplicit - The explicit type of items in the collection (highest priority)
 * @template TSchema - The schema type for validation and type inference (second priority)
 * @template TFallback - The fallback type if no explicit or schema type is provided
 * @template TKey - The type of the key returned by getKey
 *
 * @remarks
 * Type resolution follows a priority order:
 * 1. If you provide an explicit type via generic parameter, it will be used
 * 2. If no explicit type is provided but a schema is, the schema's output type will be inferred
 * 3. If neither explicit type nor schema is provided, the fallback type will be used
 *
 * You should provide EITHER an explicit type OR a schema, but not both, as they would conflict.
 */
export interface LocalOnlyCollectionConfig<TExplicit = unknown, TSchema extends StandardSchemaV1 = never, TFallback extends Record<string, unknown> = Record<string, unknown>, TKey extends string | number = string | number> {
    /**
     * Standard Collection configuration properties
     */
    id?: string;
    schema?: TSchema;
    getKey: (item: ResolveType<TExplicit, TSchema, TFallback>) => TKey;
    /**
     * Optional initial data to populate the collection with on creation
     * This data will be applied during the initial sync process
     */
    initialData?: Array<ResolveType<TExplicit, TSchema, TFallback>>;
    /**
     * Optional asynchronous handler function called after an insert operation
     * @param params Object containing transaction and collection information
     * @returns Promise resolving to any value
     */
    onInsert?: (params: InsertMutationFnParams<ResolveType<TExplicit, TSchema, TFallback>, TKey, LocalOnlyCollectionUtils>) => Promise<any>;
    /**
     * Optional asynchronous handler function called after an update operation
     * @param params Object containing transaction and collection information
     * @returns Promise resolving to any value
     */
    onUpdate?: (params: UpdateMutationFnParams<ResolveType<TExplicit, TSchema, TFallback>, TKey, LocalOnlyCollectionUtils>) => Promise<any>;
    /**
     * Optional asynchronous handler function called after a delete operation
     * @param params Object containing transaction and collection information
     * @returns Promise resolving to any value
     */
    onDelete?: (params: DeleteMutationFnParams<ResolveType<TExplicit, TSchema, TFallback>, TKey, LocalOnlyCollectionUtils>) => Promise<any>;
}
/**
 * Local-only collection utilities type (currently empty but matches the pattern)
 */
export interface LocalOnlyCollectionUtils extends UtilsRecord {
}
/**
 * Creates Local-only collection options for use with a standard Collection
 *
 * This is an in-memory collection that doesn't sync with external sources but uses a loopback sync config
 * that immediately "syncs" all optimistic changes to the collection, making them permanent.
 * Perfect for local-only data that doesn't need persistence or external synchronization.
 *
 * @template TExplicit - The explicit type of items in the collection (highest priority)
 * @template TSchema - The schema type for validation and type inference (second priority)
 * @template TFallback - The fallback type if no explicit or schema type is provided
 * @template TKey - The type of the key returned by getKey
 * @param config - Configuration options for the Local-only collection
 * @returns Collection options with utilities (currently empty but follows the pattern)
 *
 * @example
 * // Basic local-only collection
 * const collection = createCollection(
 *   localOnlyCollectionOptions({
 *     getKey: (item) => item.id,
 *   })
 * )
 *
 * @example
 * // Local-only collection with initial data
 * const collection = createCollection(
 *   localOnlyCollectionOptions({
 *     getKey: (item) => item.id,
 *     initialData: [
 *       { id: 1, name: 'Item 1' },
 *       { id: 2, name: 'Item 2' },
 *     ],
 *   })
 * )
 *
 * @example
 * // Local-only collection with mutation handlers
 * const collection = createCollection(
 *   localOnlyCollectionOptions({
 *     getKey: (item) => item.id,
 *     onInsert: async ({ transaction }) => {
 *       console.log('Item inserted:', transaction.mutations[0].modified)
 *       // Custom logic after insert
 *     },
 *   })
 * )
 */
export declare function localOnlyCollectionOptions<TExplicit = unknown, TSchema extends StandardSchemaV1 = never, TFallback extends Record<string, unknown> = Record<string, unknown>, TKey extends string | number = string | number>(config: LocalOnlyCollectionConfig<TExplicit, TSchema, TFallback, TKey>): CollectionConfig<ResolveType<TExplicit, TSchema, TFallback>, TKey> & {
    utils: LocalOnlyCollectionUtils;
};
