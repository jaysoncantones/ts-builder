{"version":3,"file":"expressions.js","sources":["../../../../src/query/compiler/expressions.ts"],"sourcesContent":["import { Func, PropRef, Value } from \"../ir.js\"\nimport type { BasicExpression } from \"../ir.js\"\n\n/**\n * Functions supported by the collection index system.\n * These are the only functions that can be used in WHERE clauses\n * that are pushed down to collection subscriptions for index optimization.\n */\nexport const SUPPORTED_COLLECTION_FUNCS = new Set([\n  `eq`,\n  `gt`,\n  `lt`,\n  `gte`,\n  `lte`,\n  `and`,\n  `or`,\n  `in`,\n])\n\n/**\n * Determines if a WHERE clause can be converted to collection-compatible BasicExpression format.\n * This checks if the expression only uses functions supported by the collection index system.\n *\n * @param whereClause - The WHERE clause to check\n * @returns True if the clause can be converted for collection index optimization\n */\nexport function isConvertibleToCollectionFilter(\n  whereClause: BasicExpression<boolean>\n): boolean {\n  const tpe = whereClause.type\n  if (tpe === `func`) {\n    // Check if this function is supported\n    if (!SUPPORTED_COLLECTION_FUNCS.has(whereClause.name)) {\n      return false\n    }\n    // Recursively check all arguments\n    return whereClause.args.every((arg) =>\n      isConvertibleToCollectionFilter(arg as BasicExpression<boolean>)\n    )\n  }\n  return [`val`, `ref`].includes(tpe)\n}\n\n/**\n * Converts a WHERE clause to BasicExpression format compatible with collection indexes.\n * This function creates proper BasicExpression class instances that the collection\n * index system can understand.\n *\n * @param whereClause - The WHERE clause to convert\n * @param collectionAlias - The alias of the collection being filtered\n * @returns The converted BasicExpression or null if conversion fails\n */\nexport function convertToBasicExpression(\n  whereClause: BasicExpression<boolean>,\n  collectionAlias: string\n): BasicExpression<boolean> | null {\n  const tpe = whereClause.type\n  if (tpe === `val`) {\n    return new Value(whereClause.value)\n  } else if (tpe === `ref`) {\n    const path = whereClause.path\n    if (Array.isArray(path)) {\n      if (path[0] === collectionAlias && path.length > 1) {\n        // Remove the table alias from the path for single-collection queries\n        return new PropRef(path.slice(1))\n      } else if (path.length === 1 && path[0] !== undefined) {\n        // Single field reference\n        return new PropRef([path[0]])\n      }\n    }\n    // Fallback for non-array paths\n    return new PropRef(Array.isArray(path) ? path : [String(path)])\n  } else {\n    // Check if this function is supported\n    if (!SUPPORTED_COLLECTION_FUNCS.has(whereClause.name)) {\n      return null\n    }\n    // Recursively convert all arguments\n    const args: Array<BasicExpression> = []\n    for (const arg of whereClause.args) {\n      const convertedArg = convertToBasicExpression(\n        arg as BasicExpression<boolean>,\n        collectionAlias\n      )\n      if (convertedArg == null) {\n        return null\n      }\n      args.push(convertedArg)\n    }\n    return new Func(whereClause.name, args)\n  }\n}\n"],"names":[],"mappings":";AAQO,MAAM,iDAAiC,IAAI;AAAA,EAChD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AASM,SAAS,gCACd,aACS;AACT,QAAM,MAAM,YAAY;AACxB,MAAI,QAAQ,QAAQ;AAElB,QAAI,CAAC,2BAA2B,IAAI,YAAY,IAAI,GAAG;AACrD,aAAO;AAAA,IACT;AAEA,WAAO,YAAY,KAAK;AAAA,MAAM,CAAC,QAC7B,gCAAgC,GAA+B;AAAA,IAAA;AAAA,EAEnE;AACA,SAAO,CAAC,OAAO,KAAK,EAAE,SAAS,GAAG;AACpC;AAWO,SAAS,yBACd,aACA,iBACiC;AACjC,QAAM,MAAM,YAAY;AACxB,MAAI,QAAQ,OAAO;AACjB,WAAO,IAAI,MAAM,YAAY,KAAK;AAAA,EACpC,WAAW,QAAQ,OAAO;AACxB,UAAM,OAAO,YAAY;AACzB,QAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,UAAI,KAAK,CAAC,MAAM,mBAAmB,KAAK,SAAS,GAAG;AAElD,eAAO,IAAI,QAAQ,KAAK,MAAM,CAAC,CAAC;AAAA,MAClC,WAAW,KAAK,WAAW,KAAK,KAAK,CAAC,MAAM,QAAW;AAErD,eAAO,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;AAAA,MAC9B;AAAA,IACF;AAEA,WAAO,IAAI,QAAQ,MAAM,QAAQ,IAAI,IAAI,OAAO,CAAC,OAAO,IAAI,CAAC,CAAC;AAAA,EAChE,OAAO;AAEL,QAAI,CAAC,2BAA2B,IAAI,YAAY,IAAI,GAAG;AACrD,aAAO;AAAA,IACT;AAEA,UAAM,OAA+B,CAAA;AACrC,eAAW,OAAO,YAAY,MAAM;AAClC,YAAM,eAAe;AAAA,QACnB;AAAA,QACA;AAAA,MAAA;AAEF,UAAI,gBAAgB,MAAM;AACxB,eAAO;AAAA,MACT;AACA,WAAK,KAAK,YAAY;AAAA,IACxB;AACA,WAAO,IAAI,KAAK,YAAY,MAAM,IAAI;AAAA,EACxC;AACF;"}