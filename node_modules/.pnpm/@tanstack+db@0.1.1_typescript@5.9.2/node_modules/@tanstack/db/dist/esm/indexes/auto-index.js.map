{"version":3,"file":"auto-index.js","sources":["../../../src/indexes/auto-index.ts"],"sourcesContent":["import { BTreeIndex } from \"./btree-index\"\nimport type { BasicExpression } from \"../query/ir\"\nimport type { CollectionImpl } from \"../collection\"\n\nexport interface AutoIndexConfig {\n  autoIndex?: `off` | `eager`\n}\n\n/**\n * Analyzes a where expression and creates indexes for all simple operations on single fields\n */\nexport function ensureIndexForExpression<\n  T extends Record<string, any>,\n  TKey extends string | number,\n>(\n  expression: BasicExpression,\n  collection: CollectionImpl<T, TKey, any, any, any>\n): void {\n  // Only proceed if auto-indexing is enabled\n  if (collection.config.autoIndex !== `eager`) {\n    return\n  }\n\n  // Don't auto-index during sync operations\n  if (\n    collection.status === `loading` ||\n    collection.status === `initialCommit`\n  ) {\n    return\n  }\n\n  // Extract all indexable expressions and create indexes for them\n  const indexableExpressions = extractIndexableExpressions(expression)\n\n  for (const { fieldName, fieldPath } of indexableExpressions) {\n    // Check if we already have an index for this field\n    const existingIndex = Array.from(collection.indexes.values()).find(\n      (index) => index.matchesField(fieldPath)\n    )\n\n    if (existingIndex) {\n      continue // Index already exists\n    }\n\n    // Create a new index for this field using the collection's createIndex method\n    try {\n      collection.createIndex((row) => (row as any)[fieldName], {\n        name: `auto_${fieldName}`,\n        indexType: BTreeIndex,\n      })\n    } catch (error) {\n      console.warn(\n        `Failed to create auto-index for field \"${fieldName}\":`,\n        error\n      )\n    }\n  }\n}\n\n/**\n * Extracts all indexable expressions from a where expression\n */\nfunction extractIndexableExpressions(\n  expression: BasicExpression\n): Array<{ fieldName: string; fieldPath: Array<string> }> {\n  const results: Array<{ fieldName: string; fieldPath: Array<string> }> = []\n\n  function extractFromExpression(expr: BasicExpression): void {\n    if (expr.type !== `func`) {\n      return\n    }\n\n    const func = expr as any\n\n    // Handle 'and' expressions by recursively processing all arguments\n    if (func.name === `and`) {\n      for (const arg of func.args) {\n        extractFromExpression(arg)\n      }\n      return\n    }\n\n    // Check if this is a supported operation\n    const supportedOperations = [`eq`, `gt`, `gte`, `lt`, `lte`, `in`]\n    if (!supportedOperations.includes(func.name)) {\n      return\n    }\n\n    // Check if the first argument is a property reference (single field)\n    if (func.args.length < 1 || func.args[0].type !== `ref`) {\n      return\n    }\n\n    const fieldRef = func.args[0]\n    const fieldPath = fieldRef.path\n\n    // Skip if it's not a simple field (e.g., nested properties or array access)\n    if (fieldPath.length !== 1) {\n      return\n    }\n\n    const fieldName = fieldPath[0]\n    results.push({ fieldName, fieldPath })\n  }\n\n  extractFromExpression(expression)\n  return results\n}\n"],"names":[],"mappings":";AAWO,SAAS,yBAId,YACA,YACM;AAEN,MAAI,WAAW,OAAO,cAAc,SAAS;AAC3C;AAAA,EACF;AAGA,MACE,WAAW,WAAW,aACtB,WAAW,WAAW,iBACtB;AACA;AAAA,EACF;AAGA,QAAM,uBAAuB,4BAA4B,UAAU;AAEnE,aAAW,EAAE,WAAW,UAAA,KAAe,sBAAsB;AAE3D,UAAM,gBAAgB,MAAM,KAAK,WAAW,QAAQ,OAAA,CAAQ,EAAE;AAAA,MAC5D,CAAC,UAAU,MAAM,aAAa,SAAS;AAAA,IAAA;AAGzC,QAAI,eAAe;AACjB;AAAA,IACF;AAGA,QAAI;AACF,iBAAW,YAAY,CAAC,QAAS,IAAY,SAAS,GAAG;AAAA,QACvD,MAAM,QAAQ,SAAS;AAAA,QACvB,WAAW;AAAA,MAAA,CACZ;AAAA,IACH,SAAS,OAAO;AACd,cAAQ;AAAA,QACN,0CAA0C,SAAS;AAAA,QACnD;AAAA,MAAA;AAAA,IAEJ;AAAA,EACF;AACF;AAKA,SAAS,4BACP,YACwD;AACxD,QAAM,UAAkE,CAAA;AAExE,WAAS,sBAAsB,MAA6B;AAC1D,QAAI,KAAK,SAAS,QAAQ;AACxB;AAAA,IACF;AAEA,UAAM,OAAO;AAGb,QAAI,KAAK,SAAS,OAAO;AACvB,iBAAW,OAAO,KAAK,MAAM;AAC3B,8BAAsB,GAAG;AAAA,MAC3B;AACA;AAAA,IACF;AAGA,UAAM,sBAAsB,CAAC,MAAM,MAAM,OAAO,MAAM,OAAO,IAAI;AACjE,QAAI,CAAC,oBAAoB,SAAS,KAAK,IAAI,GAAG;AAC5C;AAAA,IACF;AAGA,QAAI,KAAK,KAAK,SAAS,KAAK,KAAK,KAAK,CAAC,EAAE,SAAS,OAAO;AACvD;AAAA,IACF;AAEA,UAAM,WAAW,KAAK,KAAK,CAAC;AAC5B,UAAM,YAAY,SAAS;AAG3B,QAAI,UAAU,WAAW,GAAG;AAC1B;AAAA,IACF;AAEA,UAAM,YAAY,UAAU,CAAC;AAC7B,YAAQ,KAAK,EAAE,WAAW,UAAA,CAAW;AAAA,EACvC;AAEA,wBAAsB,UAAU;AAChC,SAAO;AACT;"}