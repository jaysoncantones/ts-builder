import { orderByWithFractionalIndex } from "@tanstack/db-ivm";
import { descComparator, ascComparator } from "../../utils/comparison.js";
import { compileExpression } from "./evaluators.js";
function processOrderBy(pipeline, orderByClause, limit, offset) {
  const compiledOrderBy = orderByClause.map((clause) => ({
    compiledExpression: compileExpression(clause.expression),
    direction: clause.direction
  }));
  const valueExtractor = (row) => {
    const orderByContext = { ...row };
    if (row.__select_results) {
      Object.assign(orderByContext, row.__select_results);
    }
    if (orderByClause.length > 1) {
      return compiledOrderBy.map(
        (compiled) => compiled.compiledExpression(orderByContext)
      );
    } else if (orderByClause.length === 1) {
      const compiled = compiledOrderBy[0];
      return compiled.compiledExpression(orderByContext);
    }
    return null;
  };
  const makeComparator = () => {
    return (a, b) => {
      if (orderByClause.length > 1) {
        const arrayA = a;
        const arrayB = b;
        for (let i = 0; i < orderByClause.length; i++) {
          const direction = orderByClause[i].direction;
          const compareFn = direction === `desc` ? descComparator : ascComparator;
          const result = compareFn(arrayA[i], arrayB[i]);
          if (result !== 0) {
            return result;
          }
        }
        return arrayA.length - arrayB.length;
      }
      if (orderByClause.length === 1) {
        const direction = orderByClause[0].direction;
        return direction === `desc` ? descComparator(a, b) : ascComparator(a, b);
      }
      return ascComparator(a, b);
    };
  };
  const comparator = makeComparator();
  return pipeline.pipe(
    orderByWithFractionalIndex(valueExtractor, {
      limit,
      offset,
      comparator
    })
    // orderByWithFractionalIndex returns [key, [value, index]] - we keep this format
  );
}
export {
  processOrderBy
};
//# sourceMappingURL=order-by.js.map
