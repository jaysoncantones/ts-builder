import { Value, PropRef, Func } from "../ir.js";
const SUPPORTED_COLLECTION_FUNCS = /* @__PURE__ */ new Set([
  `eq`,
  `gt`,
  `lt`,
  `gte`,
  `lte`,
  `and`,
  `or`,
  `in`
]);
function isConvertibleToCollectionFilter(whereClause) {
  const tpe = whereClause.type;
  if (tpe === `func`) {
    if (!SUPPORTED_COLLECTION_FUNCS.has(whereClause.name)) {
      return false;
    }
    return whereClause.args.every(
      (arg) => isConvertibleToCollectionFilter(arg)
    );
  }
  return [`val`, `ref`].includes(tpe);
}
function convertToBasicExpression(whereClause, collectionAlias) {
  const tpe = whereClause.type;
  if (tpe === `val`) {
    return new Value(whereClause.value);
  } else if (tpe === `ref`) {
    const path = whereClause.path;
    if (Array.isArray(path)) {
      if (path[0] === collectionAlias && path.length > 1) {
        return new PropRef(path.slice(1));
      } else if (path.length === 1 && path[0] !== void 0) {
        return new PropRef([path[0]]);
      }
    }
    return new PropRef(Array.isArray(path) ? path : [String(path)]);
  } else {
    if (!SUPPORTED_COLLECTION_FUNCS.has(whereClause.name)) {
      return null;
    }
    const args = [];
    for (const arg of whereClause.args) {
      const convertedArg = convertToBasicExpression(
        arg,
        collectionAlias
      );
      if (convertedArg == null) {
        return null;
      }
      args.push(convertedArg);
    }
    return new Func(whereClause.name, args);
  }
}
export {
  SUPPORTED_COLLECTION_FUNCS,
  convertToBasicExpression,
  isConvertibleToCollectionFilter
};
//# sourceMappingURL=expressions.js.map
