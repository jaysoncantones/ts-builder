"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const murmurhash = require("murmurhash-js");
class DefaultMap extends Map {
  constructor(defaultValue, entries) {
    super(entries);
    this.defaultValue = defaultValue;
  }
  get(key) {
    if (!this.has(key)) {
      this.set(key, this.defaultValue());
    }
    return super.get(key);
  }
  /**
   * Update the value for a key using a function.
   */
  update(key, updater) {
    const value = this.get(key);
    const newValue = updater(value);
    this.set(key, newValue);
    return newValue;
  }
}
const chunkSize = 3e4;
function chunkedArrayPush(array, other) {
  if (other.length <= chunkSize) {
    array.push(...other);
  } else {
    for (let i = 0; i < other.length; i += chunkSize) {
      const chunk = other.slice(i, i + chunkSize);
      array.push(...chunk);
    }
  }
}
const hashCache = /* @__PURE__ */ new WeakMap();
function hashReplacer(_key, value) {
  if (typeof value === `bigint`) {
    return String(value);
  } else if (typeof value === `symbol`) {
    return String(value);
  } else if (typeof value === `function`) {
    return String(value);
  } else if (value === void 0) {
    return `undefined`;
  } else if (value instanceof Map) {
    return `Map(${JSON.stringify(Array.from(value.entries()), hashReplacer)})`;
  } else if (value instanceof Set) {
    return `Set(${JSON.stringify(Array.from(value.values()), hashReplacer)})`;
  }
  return value;
}
function hash(data) {
  if (data === null || data === void 0 || typeof data !== `object` && typeof data !== `function`) {
    const serialized2 = JSON.stringify(data, hashReplacer);
    return murmurhash.murmur3(serialized2).toString(16);
  }
  if (hashCache.has(data)) {
    return hashCache.get(data);
  }
  const serialized = JSON.stringify(data, hashReplacer);
  const hashValue = murmurhash.murmur3(serialized).toString(16);
  hashCache.set(data, hashValue);
  return hashValue;
}
function binarySearch(array, value, comparator) {
  let low = 0;
  let high = array.length;
  while (low < high) {
    const mid = Math.floor((low + high) / 2);
    const comparison = comparator(array[mid], value);
    if (comparison < 0) {
      low = mid + 1;
    } else if (comparison > 0) {
      high = mid;
    } else {
      return mid;
    }
  }
  return low;
}
class ObjectIdGenerator {
  constructor() {
    this.objectIds = /* @__PURE__ */ new WeakMap();
    this.nextId = 0;
  }
  /**
   * Get a unique identifier for any value.
   * - Objects: Uses WeakMap for reference-based identity
   * - Primitives: Uses consistent string-based hashing
   */
  getId(value) {
    if (typeof value !== `object` || value === null) {
      const str = String(value);
      let hashValue = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hashValue = (hashValue << 5) - hashValue + char;
        hashValue = hashValue & hashValue;
      }
      return hashValue;
    }
    if (!this.objectIds.has(value)) {
      this.objectIds.set(value, this.nextId++);
    }
    return this.objectIds.get(value);
  }
  /**
   * Get a string representation of the ID for use in composite keys.
   */
  getStringId(value) {
    if (value === null) return `null`;
    if (value === void 0) return `undefined`;
    if (typeof value !== `object`) return `str_${String(value)}`;
    return `obj_${this.getId(value)}`;
  }
}
const globalObjectIdGenerator = new ObjectIdGenerator();
exports.DefaultMap = DefaultMap;
exports.ObjectIdGenerator = ObjectIdGenerator;
exports.binarySearch = binarySearch;
exports.chunkedArrayPush = chunkedArrayPush;
exports.globalObjectIdGenerator = globalObjectIdGenerator;
exports.hash = hash;
//# sourceMappingURL=utils.cjs.map
