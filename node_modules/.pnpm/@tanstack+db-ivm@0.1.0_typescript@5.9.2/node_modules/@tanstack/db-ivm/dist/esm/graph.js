var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _queue, _queues;
import { MultiSet } from "./multiset.js";
class DifferenceStreamReader {
  constructor(queue) {
    __privateAdd(this, _queue);
    __privateSet(this, _queue, queue);
  }
  drain() {
    const out = [...__privateGet(this, _queue)].reverse();
    __privateGet(this, _queue).length = 0;
    return out;
  }
  isEmpty() {
    return __privateGet(this, _queue).length === 0;
  }
}
_queue = new WeakMap();
class DifferenceStreamWriter {
  constructor() {
    __privateAdd(this, _queues, []);
  }
  sendData(collection) {
    if (!(collection instanceof MultiSet)) {
      collection = new MultiSet(collection);
    }
    for (const q of __privateGet(this, _queues)) {
      q.unshift(collection);
    }
  }
  newReader() {
    const q = [];
    __privateGet(this, _queues).push(q);
    return new DifferenceStreamReader(q);
  }
}
_queues = new WeakMap();
class Operator {
  constructor(id, inputs, output) {
    this.id = id;
    this.inputs = inputs;
    this.output = output;
  }
  hasPendingWork() {
    return this.inputs.some((input) => !input.isEmpty());
  }
}
class UnaryOperator extends Operator {
  constructor(id, inputA, output) {
    super(id, [inputA], output);
    this.id = id;
  }
  inputMessages() {
    return this.inputs[0].drain();
  }
}
class BinaryOperator extends Operator {
  constructor(id, inputA, inputB, output) {
    super(id, [inputA, inputB], output);
    this.id = id;
  }
  inputAMessages() {
    return this.inputs[0].drain();
  }
  inputBMessages() {
    return this.inputs[1].drain();
  }
}
class LinearUnaryOperator extends UnaryOperator {
  run() {
    for (const message of this.inputMessages()) {
      this.output.sendData(this.inner(message));
    }
  }
}
export {
  BinaryOperator,
  DifferenceStreamReader,
  DifferenceStreamWriter,
  LinearUnaryOperator,
  Operator,
  UnaryOperator
};
//# sourceMappingURL=graph.js.map
