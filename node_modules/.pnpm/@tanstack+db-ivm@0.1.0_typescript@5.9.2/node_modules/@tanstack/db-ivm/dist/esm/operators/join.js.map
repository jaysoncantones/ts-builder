{"version":3,"file":"join.js","sources":["../../../src/operators/join.ts"],"sourcesContent":["import { BinaryOperator, DifferenceStreamWriter } from \"../graph.js\"\nimport { StreamBuilder } from \"../d2.js\"\nimport { MultiSet } from \"../multiset.js\"\nimport { Index } from \"../indexes.js\"\nimport { negate } from \"./negate.js\"\nimport { map } from \"./map.js\"\nimport { concat } from \"./concat.js\"\nimport type { DifferenceStreamReader } from \"../graph.js\"\nimport type { IStreamBuilder, KeyValue, PipedOperator } from \"../types.js\"\n\n/**\n * Type of join to perform\n */\nexport type JoinType = `inner` | `left` | `right` | `full` | `anti`\n\n/**\n * Operator that joins two input streams\n */\nexport class JoinOperator<K, V1, V2> extends BinaryOperator<\n  [K, V1] | [K, V2] | [K, [V1, V2]]\n> {\n  #indexA = new Index<K, V1>()\n  #indexB = new Index<K, V2>()\n\n  constructor(\n    id: number,\n    inputA: DifferenceStreamReader<[K, V1]>,\n    inputB: DifferenceStreamReader<[K, V2]>,\n    output: DifferenceStreamWriter<[K, [V1, V2]]>\n  ) {\n    super(id, inputA, inputB, output)\n  }\n\n  run(): void {\n    const deltaA = new Index<K, V1>()\n    const deltaB = new Index<K, V2>()\n\n    // Process input A - process ALL messages, not just the first one\n    const messagesA = this.inputAMessages()\n    for (const message of messagesA) {\n      const multiSetMessage = message as unknown as MultiSet<[K, V1]>\n      for (const [item, multiplicity] of multiSetMessage.getInner()) {\n        const [key, value] = item\n        deltaA.addValue(key, [value, multiplicity])\n      }\n    }\n\n    // Process input B - process ALL messages, not just the first one\n    const messagesB = this.inputBMessages()\n    for (const message of messagesB) {\n      const multiSetMessage = message as unknown as MultiSet<[K, V2]>\n      for (const [item, multiplicity] of multiSetMessage.getInner()) {\n        const [key, value] = item\n        deltaB.addValue(key, [value, multiplicity])\n      }\n    }\n\n    // Process results\n    const results = new MultiSet<[K, [V1, V2]]>()\n\n    // Join deltaA with existing indexB\n    results.extend(deltaA.join(this.#indexB))\n\n    // Append deltaA to indexA\n    this.#indexA.append(deltaA)\n\n    // Join existing indexA with deltaB\n    results.extend(this.#indexA.join(deltaB))\n\n    // Send results\n    if (results.getInner().length > 0) {\n      this.output.sendData(results)\n    }\n\n    // Append deltaB to indexB\n    this.#indexB.append(deltaB)\n  }\n}\n\n/**\n * Joins two input streams\n * @param other - The other stream to join with\n * @param type - The type of join to perform\n */\nexport function join<\n  K,\n  V1 extends T extends KeyValue<infer _KT, infer VT> ? VT : never,\n  V2,\n  T,\n>(\n  other: IStreamBuilder<KeyValue<K, V2>>,\n  type: JoinType = `inner`\n): PipedOperator<T, KeyValue<K, [V1 | null, V2 | null]>> {\n  switch (type) {\n    case `inner`:\n      return innerJoin(other) as unknown as PipedOperator<\n        T,\n        KeyValue<K, [V1, V2]>\n      >\n    case `anti`:\n      return antiJoin(other) as unknown as PipedOperator<\n        T,\n        KeyValue<K, [V1, null]>\n      >\n    case `left`:\n      return leftJoin(other) as unknown as PipedOperator<\n        T,\n        KeyValue<K, [V1, V2 | null]>\n      >\n    case `right`:\n      return rightJoin(other) as unknown as PipedOperator<\n        T,\n        KeyValue<K, [V1 | null, V2]>\n      >\n    case `full`:\n      return fullJoin(other) as unknown as PipedOperator<\n        T,\n        KeyValue<K, [V1 | null, V2 | null]>\n      >\n    default:\n      throw new Error(`Join type ${type} is invalid`)\n  }\n}\n\n/**\n * Joins two input streams\n * @param other - The other stream to join with\n */\nexport function innerJoin<\n  K,\n  V1 extends T extends KeyValue<infer _KT, infer VT> ? VT : never,\n  V2,\n  T,\n>(\n  other: IStreamBuilder<KeyValue<K, V2>>\n): PipedOperator<T, KeyValue<K, [V1, V2]>> {\n  return (stream: IStreamBuilder<T>): IStreamBuilder<KeyValue<K, [V1, V2]>> => {\n    if (stream.graph !== other.graph) {\n      throw new Error(`Cannot join streams from different graphs`)\n    }\n    const output = new StreamBuilder<KeyValue<K, [V1, V2]>>(\n      stream.graph,\n      new DifferenceStreamWriter<KeyValue<K, [V1, V2]>>()\n    )\n    const operator = new JoinOperator<K, V1, V2>(\n      stream.graph.getNextOperatorId(),\n      stream.connectReader() as DifferenceStreamReader<KeyValue<K, V1>>,\n      other.connectReader(),\n      output.writer\n    )\n    stream.graph.addOperator(operator)\n    stream.graph.addStream(output.connectReader())\n    return output\n  }\n}\n\n/**\n * Joins two input streams\n * @param other - The other stream to join with\n */\nexport function antiJoin<\n  K,\n  V1 extends T extends KeyValue<infer _KT, infer VT> ? VT : never,\n  V2,\n  T,\n>(\n  other: IStreamBuilder<KeyValue<K, V2>>\n): PipedOperator<T, KeyValue<K, [V1, null]>> {\n  return (\n    stream: IStreamBuilder<T>\n  ): IStreamBuilder<KeyValue<K, [V1, null]>> => {\n    const matchedLeft = stream.pipe(\n      innerJoin(other),\n      map(([key, [valueLeft, _valueRight]]) => [key, valueLeft])\n    )\n    const anti = stream.pipe(\n      concat(matchedLeft.pipe(negate())),\n      // @ts-ignore TODO: fix this\n      map(([key, value]) => [key, [value, null]])\n    )\n    return anti as IStreamBuilder<KeyValue<K, [V1, null]>>\n  }\n}\n\n/**\n * Joins two input streams\n * @param other - The other stream to join with\n */\nexport function leftJoin<\n  K,\n  V1 extends T extends KeyValue<infer _KT, infer VT> ? VT : never,\n  V2,\n  T,\n>(\n  other: IStreamBuilder<KeyValue<K, V2>>\n): PipedOperator<T, KeyValue<K, [V1, V2 | null]>> {\n  return (\n    stream: IStreamBuilder<T>\n  ): IStreamBuilder<KeyValue<K, [V1, V2 | null]>> => {\n    const left = stream\n    const right = other\n    const inner = left.pipe(innerJoin(right))\n    const anti = left.pipe(antiJoin(right))\n    return inner.pipe(concat(anti)) as IStreamBuilder<\n      KeyValue<K, [V1, V2 | null]>\n    >\n  }\n}\n\n/**\n * Joins two input streams\n * @param other - The other stream to join with\n */\nexport function rightJoin<\n  K,\n  V1 extends T extends KeyValue<infer _KT, infer VT> ? VT : never,\n  V2,\n  T,\n>(\n  other: IStreamBuilder<KeyValue<K, V2>>\n): PipedOperator<T, KeyValue<K, [V1 | null, V2]>> {\n  return (\n    stream: IStreamBuilder<T>\n  ): IStreamBuilder<KeyValue<K, [V1 | null, V2]>> => {\n    const left = stream as IStreamBuilder<KeyValue<K, V1>>\n    const right = other\n    const inner = left.pipe(innerJoin(right))\n    const anti = right.pipe(\n      antiJoin(left),\n      map(([key, [a, b]]) => [key, [b, a]])\n    )\n    return inner.pipe(concat(anti)) as IStreamBuilder<\n      KeyValue<K, [V1 | null, V2]>\n    >\n  }\n}\n\n/**\n * Joins two input streams\n * @param other - The other stream to join with\n */\nexport function fullJoin<\n  K,\n  V1 extends T extends KeyValue<infer _KT, infer VT> ? VT : never,\n  V2,\n  T,\n>(\n  other: IStreamBuilder<KeyValue<K, V2>>\n): PipedOperator<T, KeyValue<K, [V1 | null, V2 | null]>> {\n  return (\n    stream: IStreamBuilder<T>\n  ): IStreamBuilder<KeyValue<K, [V1 | null, V2 | null]>> => {\n    const left = stream as IStreamBuilder<KeyValue<K, V1>>\n    const right = other\n    const inner = left.pipe(innerJoin(right))\n    const antiLeft = left.pipe(antiJoin(right))\n    const antiRight = right.pipe(\n      antiJoin(left),\n      map(([key, [a, b]]) => [key, [b, a]])\n    )\n    return inner.pipe(concat(antiLeft), concat(antiRight)) as IStreamBuilder<\n      KeyValue<K, [V1 | null, V2 | null]>\n    >\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAkBO,MAAM,qBAAgC,eAE3C;AAAA,EAIA,YACE,IACA,QACA,QACA,QACA;AACA,UAAM,IAAI,QAAQ,QAAQ,MAAM;AATlC,gCAAU,IAAI,MAAA;AACd,gCAAU,IAAI,MAAA;AAAA,EASd;AAAA,EAEA,MAAY;AACV,UAAM,SAAS,IAAI,MAAA;AACnB,UAAM,SAAS,IAAI,MAAA;AAGnB,UAAM,YAAY,KAAK,eAAA;AACvB,eAAW,WAAW,WAAW;AAC/B,YAAM,kBAAkB;AACxB,iBAAW,CAAC,MAAM,YAAY,KAAK,gBAAgB,YAAY;AAC7D,cAAM,CAAC,KAAK,KAAK,IAAI;AACrB,eAAO,SAAS,KAAK,CAAC,OAAO,YAAY,CAAC;AAAA,MAC5C;AAAA,IACF;AAGA,UAAM,YAAY,KAAK,eAAA;AACvB,eAAW,WAAW,WAAW;AAC/B,YAAM,kBAAkB;AACxB,iBAAW,CAAC,MAAM,YAAY,KAAK,gBAAgB,YAAY;AAC7D,cAAM,CAAC,KAAK,KAAK,IAAI;AACrB,eAAO,SAAS,KAAK,CAAC,OAAO,YAAY,CAAC;AAAA,MAC5C;AAAA,IACF;AAGA,UAAM,UAAU,IAAI,SAAA;AAGpB,YAAQ,OAAO,OAAO,KAAK,mBAAK,QAAO,CAAC;AAGxC,uBAAK,SAAQ,OAAO,MAAM;AAG1B,YAAQ,OAAO,mBAAK,SAAQ,KAAK,MAAM,CAAC;AAGxC,QAAI,QAAQ,WAAW,SAAS,GAAG;AACjC,WAAK,OAAO,SAAS,OAAO;AAAA,IAC9B;AAGA,uBAAK,SAAQ,OAAO,MAAM;AAAA,EAC5B;AACF;AAxDE;AACA;AA8DK,SAAS,KAMd,OACA,OAAiB,SACsC;AACvD,UAAQ,MAAA;AAAA,IACN,KAAK;AACH,aAAO,UAAU,KAAK;AAAA,IAIxB,KAAK;AACH,aAAO,SAAS,KAAK;AAAA,IAIvB,KAAK;AACH,aAAO,SAAS,KAAK;AAAA,IAIvB,KAAK;AACH,aAAO,UAAU,KAAK;AAAA,IAIxB,KAAK;AACH,aAAO,SAAS,KAAK;AAAA,IAIvB;AACE,YAAM,IAAI,MAAM,aAAa,IAAI,aAAa;AAAA,EAAA;AAEpD;AAMO,SAAS,UAMd,OACyC;AACzC,SAAO,CAAC,WAAqE;AAC3E,QAAI,OAAO,UAAU,MAAM,OAAO;AAChC,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AACA,UAAM,SAAS,IAAI;AAAA,MACjB,OAAO;AAAA,MACP,IAAI,uBAAA;AAAA,IAA8C;AAEpD,UAAM,WAAW,IAAI;AAAA,MACnB,OAAO,MAAM,kBAAA;AAAA,MACb,OAAO,cAAA;AAAA,MACP,MAAM,cAAA;AAAA,MACN,OAAO;AAAA,IAAA;AAET,WAAO,MAAM,YAAY,QAAQ;AACjC,WAAO,MAAM,UAAU,OAAO,cAAA,CAAe;AAC7C,WAAO;AAAA,EACT;AACF;AAMO,SAAS,SAMd,OAC2C;AAC3C,SAAO,CACL,WAC4C;AAC5C,UAAM,cAAc,OAAO;AAAA,MACzB,UAAU,KAAK;AAAA,MACf,IAAI,CAAC,CAAC,KAAK,CAAC,WAAW,WAAW,CAAC,MAAM,CAAC,KAAK,SAAS,CAAC;AAAA,IAAA;AAE3D,UAAM,OAAO,OAAO;AAAA,MAClB,OAAO,YAAY,KAAK,OAAA,CAAQ,CAAC;AAAA;AAAA,MAEjC,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM,CAAC,KAAK,CAAC,OAAO,IAAI,CAAC,CAAC;AAAA,IAAA;AAE5C,WAAO;AAAA,EACT;AACF;AAMO,SAAS,SAMd,OACgD;AAChD,SAAO,CACL,WACiD;AACjD,UAAM,OAAO;AACb,UAAM,QAAQ;AACd,UAAM,QAAQ,KAAK,KAAK,UAAU,KAAK,CAAC;AACxC,UAAM,OAAO,KAAK,KAAK,SAAS,KAAK,CAAC;AACtC,WAAO,MAAM,KAAK,OAAO,IAAI,CAAC;AAAA,EAGhC;AACF;AAMO,SAAS,UAMd,OACgD;AAChD,SAAO,CACL,WACiD;AACjD,UAAM,OAAO;AACb,UAAM,QAAQ;AACd,UAAM,QAAQ,KAAK,KAAK,UAAU,KAAK,CAAC;AACxC,UAAM,OAAO,MAAM;AAAA,MACjB,SAAS,IAAI;AAAA,MACb,IAAI,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;AAAA,IAAA;AAEtC,WAAO,MAAM,KAAK,OAAO,IAAI,CAAC;AAAA,EAGhC;AACF;AAMO,SAAS,SAMd,OACuD;AACvD,SAAO,CACL,WACwD;AACxD,UAAM,OAAO;AACb,UAAM,QAAQ;AACd,UAAM,QAAQ,KAAK,KAAK,UAAU,KAAK,CAAC;AACxC,UAAM,WAAW,KAAK,KAAK,SAAS,KAAK,CAAC;AAC1C,UAAM,YAAY,MAAM;AAAA,MACtB,SAAS,IAAI;AAAA,MACb,IAAI,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;AAAA,IAAA;AAEtC,WAAO,MAAM,KAAK,OAAO,QAAQ,GAAG,OAAO,SAAS,CAAC;AAAA,EAGvD;AACF;"}