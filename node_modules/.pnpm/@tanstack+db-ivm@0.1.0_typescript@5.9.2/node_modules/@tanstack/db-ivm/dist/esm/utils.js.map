{"version":3,"file":"utils.js","sources":["../../src/utils.ts"],"sourcesContent":["import murmurhash from \"murmurhash-js\"\n\n/**\n * A map that returns a default value for keys that are not present.\n */\nexport class DefaultMap<K, V> extends Map<K, V> {\n  constructor(\n    private defaultValue: () => V,\n    entries?: Iterable<[K, V]>\n  ) {\n    super(entries)\n  }\n\n  get(key: K): V {\n    if (!this.has(key)) {\n      this.set(key, this.defaultValue())\n    }\n    return super.get(key)!\n  }\n\n  /**\n   * Update the value for a key using a function.\n   */\n  update(key: K, updater: (value: V) => V): V {\n    const value = this.get(key)\n    const newValue = updater(value)\n    this.set(key, newValue)\n    return newValue\n  }\n}\n\n// JS engines have various limits on how many args can be passed to a function\n// with a spread operator, so we need to split the operation into chunks\n// 32767 is the max for Chrome 14, all others are higher\n// TODO: investigate the performance of this and other approaches\nconst chunkSize = 30000\nexport function chunkedArrayPush(array: Array<unknown>, other: Array<unknown>) {\n  if (other.length <= chunkSize) {\n    array.push(...other)\n  } else {\n    for (let i = 0; i < other.length; i += chunkSize) {\n      const chunk = other.slice(i, i + chunkSize)\n      array.push(...chunk)\n    }\n  }\n}\n\nconst hashCache = new WeakMap()\n\n/**\n * Replacer function for JSON.stringify that converts unsupported types to strings\n */\nfunction hashReplacer(_key: string, value: any): any {\n  if (typeof value === `bigint`) {\n    return String(value)\n  } else if (typeof value === `symbol`) {\n    return String(value)\n  } else if (typeof value === `function`) {\n    return String(value)\n  } else if (value === undefined) {\n    return `undefined`\n  } else if (value instanceof Map) {\n    return `Map(${JSON.stringify(Array.from(value.entries()), hashReplacer)})`\n  } else if (value instanceof Set) {\n    return `Set(${JSON.stringify(Array.from(value.values()), hashReplacer)})`\n  }\n  return value\n}\n\n/**\n * A hash method that caches the hash of a value in a week map\n */\nexport function hash(data: any): string {\n  if (\n    data === null ||\n    data === undefined ||\n    (typeof data !== `object` && typeof data !== `function`)\n  ) {\n    // Can't be cached in the weak map because it's not an object\n    const serialized = JSON.stringify(data, hashReplacer)\n    return murmurhash.murmur3(serialized).toString(16)\n  }\n\n  if (hashCache.has(data)) {\n    return hashCache.get(data)\n  }\n\n  const serialized = JSON.stringify(data, hashReplacer)\n  const hashValue = murmurhash.murmur3(serialized).toString(16)\n  hashCache.set(data, hashValue)\n  return hashValue\n}\n\nexport function binarySearch<T>(\n  array: Array<T>,\n  value: T,\n  comparator: (a: T, b: T) => number\n): number {\n  let low = 0\n  let high = array.length\n  while (low < high) {\n    const mid = Math.floor((low + high) / 2)\n    const comparison = comparator(array[mid]!, value)\n    if (comparison < 0) {\n      low = mid + 1\n    } else if (comparison > 0) {\n      high = mid\n    } else {\n      return mid\n    }\n  }\n  return low\n}\n\n/**\n * Utility for generating unique IDs for objects and values.\n * Uses WeakMap for object reference tracking and consistent hashing for primitives.\n */\nexport class ObjectIdGenerator {\n  private objectIds = new WeakMap<object, number>()\n  private nextId = 0\n\n  /**\n   * Get a unique identifier for any value.\n   * - Objects: Uses WeakMap for reference-based identity\n   * - Primitives: Uses consistent string-based hashing\n   */\n  getId(value: any): number {\n    // For primitives, use a simple hash of their string representation\n    if (typeof value !== `object` || value === null) {\n      const str = String(value)\n      let hashValue = 0\n      for (let i = 0; i < str.length; i++) {\n        const char = str.charCodeAt(i)\n        hashValue = (hashValue << 5) - hashValue + char\n        hashValue = hashValue & hashValue // Convert to 32-bit integer\n      }\n      return hashValue\n    }\n\n    // For objects, use WeakMap to assign unique IDs\n    if (!this.objectIds.has(value)) {\n      this.objectIds.set(value, this.nextId++)\n    }\n    return this.objectIds.get(value)!\n  }\n\n  /**\n   * Get a string representation of the ID for use in composite keys.\n   */\n  getStringId(value: any): string {\n    if (value === null) return `null`\n    if (value === undefined) return `undefined`\n    if (typeof value !== `object`) return `str_${String(value)}`\n\n    return `obj_${this.getId(value)}`\n  }\n}\n\n/**\n * Global instance for cases where a shared object ID space is needed.\n */\nexport const globalObjectIdGenerator = new ObjectIdGenerator()\n"],"names":["serialized"],"mappings":";AAKO,MAAM,mBAAyB,IAAU;AAAA,EAC9C,YACU,cACR,SACA;AACA,UAAM,OAAO;AAHL,SAAA,eAAA;AAAA,EAIV;AAAA,EAEA,IAAI,KAAW;AACb,QAAI,CAAC,KAAK,IAAI,GAAG,GAAG;AAClB,WAAK,IAAI,KAAK,KAAK,aAAA,CAAc;AAAA,IACnC;AACA,WAAO,MAAM,IAAI,GAAG;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,KAAQ,SAA6B;AAC1C,UAAM,QAAQ,KAAK,IAAI,GAAG;AAC1B,UAAM,WAAW,QAAQ,KAAK;AAC9B,SAAK,IAAI,KAAK,QAAQ;AACtB,WAAO;AAAA,EACT;AACF;AAMA,MAAM,YAAY;AACX,SAAS,iBAAiB,OAAuB,OAAuB;AAC7E,MAAI,MAAM,UAAU,WAAW;AAC7B,UAAM,KAAK,GAAG,KAAK;AAAA,EACrB,OAAO;AACL,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,WAAW;AAChD,YAAM,QAAQ,MAAM,MAAM,GAAG,IAAI,SAAS;AAC1C,YAAM,KAAK,GAAG,KAAK;AAAA,IACrB;AAAA,EACF;AACF;AAEA,MAAM,gCAAgB,QAAA;AAKtB,SAAS,aAAa,MAAc,OAAiB;AACnD,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO,OAAO,KAAK;AAAA,EACrB,WAAW,OAAO,UAAU,UAAU;AACpC,WAAO,OAAO,KAAK;AAAA,EACrB,WAAW,OAAO,UAAU,YAAY;AACtC,WAAO,OAAO,KAAK;AAAA,EACrB,WAAW,UAAU,QAAW;AAC9B,WAAO;AAAA,EACT,WAAW,iBAAiB,KAAK;AAC/B,WAAO,OAAO,KAAK,UAAU,MAAM,KAAK,MAAM,QAAA,CAAS,GAAG,YAAY,CAAC;AAAA,EACzE,WAAW,iBAAiB,KAAK;AAC/B,WAAO,OAAO,KAAK,UAAU,MAAM,KAAK,MAAM,OAAA,CAAQ,GAAG,YAAY,CAAC;AAAA,EACxE;AACA,SAAO;AACT;AAKO,SAAS,KAAK,MAAmB;AACtC,MACE,SAAS,QACT,SAAS,UACR,OAAO,SAAS,YAAY,OAAO,SAAS,YAC7C;AAEA,UAAMA,cAAa,KAAK,UAAU,MAAM,YAAY;AACpD,WAAO,WAAW,QAAQA,WAAU,EAAE,SAAS,EAAE;AAAA,EACnD;AAEA,MAAI,UAAU,IAAI,IAAI,GAAG;AACvB,WAAO,UAAU,IAAI,IAAI;AAAA,EAC3B;AAEA,QAAM,aAAa,KAAK,UAAU,MAAM,YAAY;AACpD,QAAM,YAAY,WAAW,QAAQ,UAAU,EAAE,SAAS,EAAE;AAC5D,YAAU,IAAI,MAAM,SAAS;AAC7B,SAAO;AACT;AAEO,SAAS,aACd,OACA,OACA,YACQ;AACR,MAAI,MAAM;AACV,MAAI,OAAO,MAAM;AACjB,SAAO,MAAM,MAAM;AACjB,UAAM,MAAM,KAAK,OAAO,MAAM,QAAQ,CAAC;AACvC,UAAM,aAAa,WAAW,MAAM,GAAG,GAAI,KAAK;AAChD,QAAI,aAAa,GAAG;AAClB,YAAM,MAAM;AAAA,IACd,WAAW,aAAa,GAAG;AACzB,aAAO;AAAA,IACT,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AAMO,MAAM,kBAAkB;AAAA,EAAxB,cAAA;AACL,SAAQ,gCAAgB,QAAA;AACxB,SAAQ,SAAS;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOjB,MAAM,OAAoB;AAExB,QAAI,OAAO,UAAU,YAAY,UAAU,MAAM;AAC/C,YAAM,MAAM,OAAO,KAAK;AACxB,UAAI,YAAY;AAChB,eAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,cAAM,OAAO,IAAI,WAAW,CAAC;AAC7B,qBAAa,aAAa,KAAK,YAAY;AAC3C,oBAAY,YAAY;AAAA,MAC1B;AACA,aAAO;AAAA,IACT;AAGA,QAAI,CAAC,KAAK,UAAU,IAAI,KAAK,GAAG;AAC9B,WAAK,UAAU,IAAI,OAAO,KAAK,QAAQ;AAAA,IACzC;AACA,WAAO,KAAK,UAAU,IAAI,KAAK;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,OAAoB;AAC9B,QAAI,UAAU,KAAM,QAAO;AAC3B,QAAI,UAAU,OAAW,QAAO;AAChC,QAAI,OAAO,UAAU,iBAAiB,OAAO,OAAO,KAAK,CAAC;AAE1D,WAAO,OAAO,KAAK,MAAM,KAAK,CAAC;AAAA,EACjC;AACF;AAKO,MAAM,0BAA0B,IAAI,kBAAA;"}