{"version":3,"file":"orderBy.js","sources":["../../../src/operators/orderBy.ts"],"sourcesContent":["import { topK, topKWithIndex } from \"./topK.js\"\nimport { topKWithFractionalIndex } from \"./topKWithFractionalIndex.js\"\nimport { map } from \"./map.js\"\nimport { innerJoin } from \"./join.js\"\nimport { consolidate } from \"./consolidate.js\"\nimport type { KeyValue } from \"../types.js\"\nimport type { IStreamBuilder } from \"../types\"\n\nexport interface OrderByOptions<Ve> {\n  comparator?: (a: Ve, b: Ve) => number\n  limit?: number\n  offset?: number\n}\n\n/**\n * Orders the elements and limits the number of results, with optional offset\n * This requires a keyed stream, and uses the `topK` operator to order all the elements.\n *\n * @param valueExtractor - A function that extracts the value to order by from the element\n * @param options - An optional object containing comparator, limit and offset properties\n * @returns A piped operator that orders the elements and limits the number of results\n */\nexport function orderBy<T extends KeyValue<unknown, unknown>, Ve = unknown>(\n  valueExtractor: (\n    value: T extends KeyValue<unknown, infer V> ? V : never\n  ) => Ve,\n  options?: OrderByOptions<Ve>\n) {\n  const limit = options?.limit ?? Infinity\n  const offset = options?.offset ?? 0\n  const comparator =\n    options?.comparator ??\n    ((a, b) => {\n      // Default to JS like ordering\n      if (a === b) return 0\n      if (a < b) return -1\n      return 1\n    })\n\n  return (stream: IStreamBuilder<T>): IStreamBuilder<T> => {\n    type KeyType = T extends KeyValue<infer K, unknown> ? K : never\n\n    return stream.pipe(\n      map(\n        ([key, value]) =>\n          [\n            null,\n            [\n              key,\n              valueExtractor(\n                value as T extends KeyValue<unknown, infer V> ? V : never\n              ),\n            ],\n          ] as KeyValue<null, [KeyType, Ve]>\n      ),\n      topK((a, b) => comparator(a[1], b[1]), { limit, offset }),\n      map(([_, [key]]) => [key, null] as KeyValue<KeyType, null>),\n      innerJoin(stream),\n      map(([key, value]) => {\n        return [key, value[1]] as T\n      }),\n      consolidate()\n    )\n  }\n}\n\n/**\n * Orders the elements and limits the number of results, with optional offset and\n * annotates the value with the index.\n * This requires a keyed stream, and uses the `topKWithIndex` operator to order all the elements.\n *\n * @param valueExtractor - A function that extracts the value to order by from the element\n * @param options - An optional object containing comparator, limit and offset properties\n * @returns A piped operator that orders the elements and limits the number of results\n */\nexport function orderByWithIndex<\n  T extends KeyValue<unknown, unknown>,\n  Ve = unknown,\n>(\n  valueExtractor: (\n    value: T extends KeyValue<unknown, infer V> ? V : never\n  ) => Ve,\n  options?: OrderByOptions<Ve>\n) {\n  const limit = options?.limit ?? Infinity\n  const offset = options?.offset ?? 0\n  const comparator =\n    options?.comparator ??\n    ((a, b) => {\n      // Default to JS like ordering\n      if (a === b) return 0\n      if (a < b) return -1\n      return 1\n    })\n\n  return (\n    stream: IStreamBuilder<T>\n  ): IStreamBuilder<\n    KeyValue<\n      T extends KeyValue<infer K, unknown> ? K : never,\n      [T extends KeyValue<unknown, infer V> ? V : never, number]\n    >\n  > => {\n    type KeyType = T extends KeyValue<infer K, unknown> ? K : never\n    type ValueType = T extends KeyValue<unknown, infer V> ? V : never\n\n    return stream.pipe(\n      map(\n        ([key, value]) =>\n          [\n            null,\n            [\n              key,\n              valueExtractor(\n                value as T extends KeyValue<unknown, infer V> ? V : never\n              ),\n            ],\n          ] as KeyValue<null, [KeyType, Ve]>\n      ),\n      topKWithIndex((a, b) => comparator(a[1], b[1]), { limit, offset }),\n      map(([_, [[key], index]]) => [key, index] as KeyValue<KeyType, number>),\n      innerJoin(stream),\n      map(([key, [index, value]]) => {\n        return [key, [value, index]] as KeyValue<KeyType, [ValueType, number]>\n      }),\n      consolidate()\n    )\n  }\n}\n\nexport function orderByWithFractionalIndexBase<\n  T extends KeyValue<unknown, unknown>,\n  Ve = unknown,\n>(\n  topKFunction: typeof topKWithFractionalIndex,\n  valueExtractor: (\n    value: T extends KeyValue<unknown, infer V> ? V : never\n  ) => Ve,\n  options?: OrderByOptions<Ve>\n) {\n  const limit = options?.limit ?? Infinity\n  const offset = options?.offset ?? 0\n  const comparator =\n    options?.comparator ??\n    ((a, b) => {\n      // Default to JS like ordering\n      if (a === b) return 0\n      if (a < b) return -1\n      return 1\n    })\n\n  return (\n    stream: IStreamBuilder<T>\n  ): IStreamBuilder<\n    KeyValue<\n      T extends KeyValue<infer K, unknown> ? K : never,\n      [T extends KeyValue<unknown, infer V> ? V : never, string]\n    >\n  > => {\n    type KeyType = T extends KeyValue<infer K, unknown> ? K : never\n    type ValueType = T extends KeyValue<unknown, infer V> ? V : never\n\n    return stream.pipe(\n      map(\n        ([key, value]) =>\n          [\n            null,\n            [\n              key,\n              valueExtractor(\n                value as T extends KeyValue<unknown, infer V> ? V : never\n              ),\n            ],\n          ] as KeyValue<null, [KeyType, Ve]>\n      ),\n      topKFunction((a, b) => comparator(a[1], b[1]), {\n        limit,\n        offset,\n      }),\n      map(([_, [[key], index]]) => [key, index] as KeyValue<KeyType, string>),\n      innerJoin(stream),\n      map(([key, [index, value]]) => {\n        return [key, [value, index]] as KeyValue<KeyType, [ValueType, string]>\n      }),\n      consolidate()\n    )\n  }\n}\n\n/**\n * Orders the elements and limits the number of results, with optional offset and\n * annotates the value with a fractional index.\n * This requires a keyed stream, and uses the `topKWithFractionalIndex` operator to order all the elements.\n *\n * @param valueExtractor - A function that extracts the value to order by from the element\n * @param options - An optional object containing comparator, limit and offset properties\n * @returns A piped operator that orders the elements and limits the number of results\n */\nexport function orderByWithFractionalIndex<\n  T extends KeyValue<unknown, unknown>,\n  Ve = unknown,\n>(\n  valueExtractor: (\n    value: T extends KeyValue<unknown, infer V> ? V : never\n  ) => Ve,\n  options?: OrderByOptions<Ve>\n) {\n  return orderByWithFractionalIndexBase(\n    topKWithFractionalIndex,\n    valueExtractor,\n    options\n  )\n}\n"],"names":[],"mappings":"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"}