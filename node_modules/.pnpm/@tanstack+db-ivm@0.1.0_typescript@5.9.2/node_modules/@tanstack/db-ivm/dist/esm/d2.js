var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var _streams, _operators, _nextOperatorId, _finalized, _D2_instances, checkNotFinalized_fn, _graph, _writer;
import { DifferenceStreamWriter } from "./graph.js";
class D2 {
  constructor() {
    __privateAdd(this, _D2_instances);
    __privateAdd(this, _streams, []);
    __privateAdd(this, _operators, []);
    __privateAdd(this, _nextOperatorId, 0);
    __privateAdd(this, _finalized, false);
  }
  getNextOperatorId() {
    __privateMethod(this, _D2_instances, checkNotFinalized_fn).call(this);
    return __privateWrapper(this, _nextOperatorId)._++;
  }
  newInput() {
    __privateMethod(this, _D2_instances, checkNotFinalized_fn).call(this);
    const writer = new DifferenceStreamWriter();
    const streamBuilder = new RootStreamBuilder(this, writer);
    __privateGet(this, _streams).push(streamBuilder.connectReader());
    return streamBuilder;
  }
  addOperator(operator) {
    __privateMethod(this, _D2_instances, checkNotFinalized_fn).call(this);
    __privateGet(this, _operators).push(operator);
  }
  addStream(stream) {
    __privateMethod(this, _D2_instances, checkNotFinalized_fn).call(this);
    __privateGet(this, _streams).push(stream);
  }
  finalize() {
    __privateMethod(this, _D2_instances, checkNotFinalized_fn).call(this);
    __privateSet(this, _finalized, true);
  }
  step() {
    if (!__privateGet(this, _finalized)) {
      throw new Error(`Graph not finalized`);
    }
    for (const op of __privateGet(this, _operators)) {
      op.run();
    }
  }
  pendingWork() {
    return __privateGet(this, _operators).some((op) => op.hasPendingWork());
  }
  run() {
    while (this.pendingWork()) {
      this.step();
    }
  }
}
_streams = new WeakMap();
_operators = new WeakMap();
_nextOperatorId = new WeakMap();
_finalized = new WeakMap();
_D2_instances = new WeakSet();
checkNotFinalized_fn = function() {
  if (__privateGet(this, _finalized)) {
    throw new Error(`Graph already finalized`);
  }
};
class StreamBuilder {
  constructor(graph, writer) {
    __privateAdd(this, _graph);
    __privateAdd(this, _writer);
    __privateSet(this, _graph, graph);
    __privateSet(this, _writer, writer);
  }
  connectReader() {
    return __privateGet(this, _writer).newReader();
  }
  get writer() {
    return __privateGet(this, _writer);
  }
  get graph() {
    return __privateGet(this, _graph);
  }
  pipe(...operators) {
    return operators.reduce((stream, operator) => {
      return operator(stream);
    }, this);
  }
}
_graph = new WeakMap();
_writer = new WeakMap();
class RootStreamBuilder extends StreamBuilder {
  sendData(collection) {
    this.writer.sendData(collection);
  }
}
export {
  D2,
  RootStreamBuilder,
  StreamBuilder
};
//# sourceMappingURL=d2.js.map
