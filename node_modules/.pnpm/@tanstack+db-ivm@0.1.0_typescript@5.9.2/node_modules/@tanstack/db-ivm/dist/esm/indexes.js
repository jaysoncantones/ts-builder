var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _inner;
import { MultiSet } from "./multiset.js";
import { DefaultMap } from "./utils.js";
class Index {
  constructor() {
    __privateAdd(this, _inner);
    __privateSet(this, _inner, new DefaultMap(() => /* @__PURE__ */ new Map()));
  }
  toString(indent = false) {
    return `Index(${JSON.stringify(
      [...__privateGet(this, _inner)].map(([k, valueMap]) => [k, [...valueMap]]),
      void 0,
      indent ? `  ` : void 0
    )})`;
  }
  get(key) {
    const valueMap = __privateGet(this, _inner).get(key);
    return [...valueMap.entries()];
  }
  getMultiplicity(key, value) {
    const valueMap = __privateGet(this, _inner).get(key);
    return valueMap.get(value) ?? 0;
  }
  entries() {
    return __privateGet(this, _inner).entries();
  }
  keys() {
    return __privateGet(this, _inner).keys();
  }
  has(key) {
    return __privateGet(this, _inner).has(key);
  }
  get size() {
    return __privateGet(this, _inner).size;
  }
  addValue(key, value) {
    const [val, multiplicity] = value;
    const valueMap = __privateGet(this, _inner).get(key);
    const existingMultiplicity = valueMap.get(val) ?? 0;
    const newMultiplicity = existingMultiplicity + multiplicity;
    if (multiplicity !== 0) {
      if (newMultiplicity === 0) {
        valueMap.delete(val);
      } else {
        valueMap.set(val, newMultiplicity);
      }
    }
  }
  append(other) {
    for (const [key, otherValueMap] of other.entries()) {
      const thisValueMap = __privateGet(this, _inner).get(key);
      for (const [value, multiplicity] of otherValueMap.entries()) {
        const existingMultiplicity = thisValueMap.get(value) ?? 0;
        const newMultiplicity = existingMultiplicity + multiplicity;
        if (newMultiplicity === 0) {
          thisValueMap.delete(value);
        } else {
          thisValueMap.set(value, newMultiplicity);
        }
      }
    }
  }
  join(other) {
    const result = [];
    if (this.size <= other.size) {
      for (const [key, valueMap] of this.entries()) {
        if (!other.has(key)) continue;
        const otherValues = other.get(key);
        for (const [val1, mul1] of valueMap.entries()) {
          for (const [val2, mul2] of otherValues) {
            if (mul1 !== 0 && mul2 !== 0) {
              result.push([[key, [val1, val2]], mul1 * mul2]);
            }
          }
        }
      }
    } else {
      for (const [key, otherValueMap] of other.entries()) {
        if (!this.has(key)) continue;
        const values = this.get(key);
        for (const [val2, mul2] of otherValueMap.entries()) {
          for (const [val1, mul1] of values) {
            if (mul1 !== 0 && mul2 !== 0) {
              result.push([[key, [val1, val2]], mul1 * mul2]);
            }
          }
        }
      }
    }
    return new MultiSet(result);
  }
}
_inner = new WeakMap();
export {
  Index
};
//# sourceMappingURL=indexes.js.map
