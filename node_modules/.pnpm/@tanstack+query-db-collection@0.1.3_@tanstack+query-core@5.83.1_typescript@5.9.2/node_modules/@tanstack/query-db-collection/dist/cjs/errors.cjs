"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const db = require("@tanstack/db");
class QueryCollectionError extends db.TanStackDBError {
  constructor(message) {
    super(message);
    this.name = `QueryCollectionError`;
  }
}
class QueryKeyRequiredError extends QueryCollectionError {
  constructor() {
    super(`[QueryCollection] queryKey must be provided.`);
    this.name = `QueryKeyRequiredError`;
  }
}
class QueryFnRequiredError extends QueryCollectionError {
  constructor() {
    super(`[QueryCollection] queryFn must be provided.`);
    this.name = `QueryFnRequiredError`;
  }
}
class QueryClientRequiredError extends QueryCollectionError {
  constructor() {
    super(`[QueryCollection] queryClient must be provided.`);
    this.name = `QueryClientRequiredError`;
  }
}
class GetKeyRequiredError extends QueryCollectionError {
  constructor() {
    super(`[QueryCollection] getKey must be provided.`);
    this.name = `GetKeyRequiredError`;
  }
}
class SyncNotInitializedError extends QueryCollectionError {
  constructor() {
    super(
      `Collection must be in 'ready' state for manual sync operations. Sync not initialized yet.`
    );
    this.name = `SyncNotInitializedError`;
  }
}
class InvalidItemStructureError extends QueryCollectionError {
  constructor(message) {
    super(`Invalid item structure: ${message}`);
    this.name = `InvalidItemStructureError`;
  }
}
class ItemNotFoundError extends QueryCollectionError {
  constructor(key) {
    super(`Item with key '${key}' does not exist.`);
    this.name = `ItemNotFoundError`;
  }
}
class DuplicateKeyInBatchError extends QueryCollectionError {
  constructor(key) {
    super(`Duplicate key '${key}' found within batch operations`);
    this.name = `DuplicateKeyInBatchError`;
  }
}
class UpdateOperationItemNotFoundError extends QueryCollectionError {
  constructor(key) {
    super(`Update operation: Item with key '${key}' does not exist`);
    this.name = `UpdateOperationItemNotFoundError`;
  }
}
class DeleteOperationItemNotFoundError extends QueryCollectionError {
  constructor(key) {
    super(`Delete operation: Item with key '${key}' does not exist`);
    this.name = `DeleteOperationItemNotFoundError`;
  }
}
class InvalidSyncOperationError extends QueryCollectionError {
  constructor(message) {
    super(`Invalid sync operation: ${message}`);
    this.name = `InvalidSyncOperationError`;
  }
}
class UnknownOperationTypeError extends QueryCollectionError {
  constructor(type) {
    super(`Unknown operation type: ${type}`);
    this.name = `UnknownOperationTypeError`;
  }
}
class MissingKeyFieldError extends QueryCollectionError {
  constructor(operation, message) {
    super(`${operation} item must contain the key field: ${message}`);
    this.name = `MissingKeyFieldError`;
  }
}
exports.DeleteOperationItemNotFoundError = DeleteOperationItemNotFoundError;
exports.DuplicateKeyInBatchError = DuplicateKeyInBatchError;
exports.GetKeyRequiredError = GetKeyRequiredError;
exports.InvalidItemStructureError = InvalidItemStructureError;
exports.InvalidSyncOperationError = InvalidSyncOperationError;
exports.ItemNotFoundError = ItemNotFoundError;
exports.MissingKeyFieldError = MissingKeyFieldError;
exports.QueryClientRequiredError = QueryClientRequiredError;
exports.QueryCollectionError = QueryCollectionError;
exports.QueryFnRequiredError = QueryFnRequiredError;
exports.QueryKeyRequiredError = QueryKeyRequiredError;
exports.SyncNotInitializedError = SyncNotInitializedError;
exports.UnknownOperationTypeError = UnknownOperationTypeError;
exports.UpdateOperationItemNotFoundError = UpdateOperationItemNotFoundError;
//# sourceMappingURL=errors.cjs.map
