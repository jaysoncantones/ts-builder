import { QueryObserver } from "@tanstack/query-core";
import { QueryKeyRequiredError, QueryFnRequiredError, QueryClientRequiredError, GetKeyRequiredError } from "./errors.js";
import { createWriteUtils } from "./manual-sync.js";
function queryCollectionOptions(config) {
  const {
    queryKey,
    queryFn,
    queryClient,
    enabled,
    refetchInterval,
    retry,
    retryDelay,
    staleTime,
    getKey,
    onInsert,
    onUpdate,
    onDelete,
    meta,
    ...baseCollectionConfig
  } = config;
  if (!queryKey) {
    throw new QueryKeyRequiredError();
  }
  if (!queryFn) {
    throw new QueryFnRequiredError();
  }
  if (!queryClient) {
    throw new QueryClientRequiredError();
  }
  if (!getKey) {
    throw new GetKeyRequiredError();
  }
  const internalSync = (params) => {
    const { begin, write, commit, markReady, collection } = params;
    const observerOptions = {
      queryKey,
      queryFn,
      meta,
      enabled,
      refetchInterval,
      retry,
      retryDelay,
      staleTime,
      structuralSharing: true,
      notifyOnChangeProps: `all`
    };
    const localObserver = new QueryObserver(queryClient, observerOptions);
    const actualUnsubscribeFn = localObserver.subscribe((result) => {
      if (result.isSuccess) {
        const newItemsArray = result.data;
        if (!Array.isArray(newItemsArray) || newItemsArray.some((item) => typeof item !== `object`)) {
          console.error(
            `[QueryCollection] queryFn did not return an array of objects. Skipping update.`,
            newItemsArray
          );
          return;
        }
        const currentSyncedItems = new Map(collection.syncedData);
        const newItemsMap = /* @__PURE__ */ new Map();
        newItemsArray.forEach((item) => {
          const key = getKey(item);
          newItemsMap.set(key, item);
        });
        begin();
        const shallowEqual = (obj1, obj2) => {
          const keys1 = Object.keys(obj1);
          const keys2 = Object.keys(obj2);
          if (keys1.length !== keys2.length) return false;
          return keys1.every((key) => {
            if (typeof obj1[key] === `function`) return true;
            if (typeof obj1[key] === `object` && obj1[key] !== null) {
              return obj1[key] === obj2[key];
            }
            return obj1[key] === obj2[key];
          });
        };
        currentSyncedItems.forEach((oldItem, key) => {
          const newItem = newItemsMap.get(key);
          if (!newItem) {
            write({ type: `delete`, value: oldItem });
          } else if (!shallowEqual(
            oldItem,
            newItem
          )) {
            write({ type: `update`, value: newItem });
          }
        });
        newItemsMap.forEach((newItem, key) => {
          if (!currentSyncedItems.has(key)) {
            write({ type: `insert`, value: newItem });
          }
        });
        commit();
        markReady();
      } else if (result.isError) {
        console.error(
          `[QueryCollection] Error observing query ${String(queryKey)}:`,
          result.error
        );
        markReady();
      }
    });
    return async () => {
      actualUnsubscribeFn();
      await queryClient.cancelQueries({ queryKey });
      queryClient.removeQueries({ queryKey });
    };
  };
  const refetch = async () => {
    return queryClient.refetchQueries({
      queryKey
    });
  };
  let writeContext = null;
  const enhancedInternalSync = (params) => {
    const { begin, write, commit, collection } = params;
    writeContext = {
      collection,
      queryClient,
      queryKey,
      getKey,
      begin,
      write,
      commit
    };
    return internalSync(params);
  };
  const writeUtils = createWriteUtils(
    () => writeContext
  );
  const wrappedOnInsert = onInsert ? async (params) => {
    const handlerResult = await onInsert(params) ?? {};
    const shouldRefetch = handlerResult.refetch !== false;
    if (shouldRefetch) {
      await refetch();
    }
    return handlerResult;
  } : void 0;
  const wrappedOnUpdate = onUpdate ? async (params) => {
    const handlerResult = await onUpdate(params) ?? {};
    const shouldRefetch = handlerResult.refetch !== false;
    if (shouldRefetch) {
      await refetch();
    }
    return handlerResult;
  } : void 0;
  const wrappedOnDelete = onDelete ? async (params) => {
    const handlerResult = await onDelete(params) ?? {};
    const shouldRefetch = handlerResult.refetch !== false;
    if (shouldRefetch) {
      await refetch();
    }
    return handlerResult;
  } : void 0;
  return {
    ...baseCollectionConfig,
    getKey,
    sync: { sync: enhancedInternalSync },
    onInsert: wrappedOnInsert,
    onUpdate: wrappedOnUpdate,
    onDelete: wrappedOnDelete,
    utils: {
      refetch,
      ...writeUtils
    }
  };
}
export {
  queryCollectionOptions
};
//# sourceMappingURL=query.js.map
