import { SyncNotInitializedError, DuplicateKeyInBatchError, UpdateOperationItemNotFoundError, DeleteOperationItemNotFoundError } from "./errors.js";
function normalizeOperations(ops, ctx) {
  const operations = Array.isArray(ops) ? ops : [ops];
  const normalized = [];
  for (const op of operations) {
    if (op.type === `delete`) {
      const keys = Array.isArray(op.key) ? op.key : [op.key];
      for (const key of keys) {
        normalized.push({ type: `delete`, key });
      }
    } else {
      const items = Array.isArray(op.data) ? op.data : [op.data];
      for (const item of items) {
        let key;
        if (op.type === `update`) {
          key = ctx.getKey(item);
        } else {
          const resolved = ctx.collection.validateData(
            item,
            op.type === `upsert` ? `insert` : op.type
          );
          key = ctx.getKey(resolved);
        }
        normalized.push({ type: op.type, key, data: item });
      }
    }
  }
  return normalized;
}
function validateOperations(operations, ctx) {
  const seenKeys = /* @__PURE__ */ new Set();
  for (const op of operations) {
    if (seenKeys.has(op.key)) {
      throw new DuplicateKeyInBatchError(op.key);
    }
    seenKeys.add(op.key);
    if (op.type === `update`) {
      if (!ctx.collection.has(op.key)) {
        throw new UpdateOperationItemNotFoundError(op.key);
      }
    } else if (op.type === `delete`) {
      if (!ctx.collection.has(op.key)) {
        throw new DeleteOperationItemNotFoundError(op.key);
      }
    }
  }
}
function performWriteOperations(operations, ctx) {
  const normalized = normalizeOperations(operations, ctx);
  validateOperations(normalized, ctx);
  ctx.begin();
  for (const op of normalized) {
    switch (op.type) {
      case `insert`: {
        const resolved = ctx.collection.validateData(op.data, `insert`);
        ctx.write({
          type: `insert`,
          value: resolved
        });
        break;
      }
      case `update`: {
        const currentItem = ctx.collection.get(op.key);
        const updatedItem = {
          ...currentItem,
          ...op.data
        };
        const resolved = ctx.collection.validateData(
          updatedItem,
          `update`,
          op.key
        );
        ctx.write({
          type: `update`,
          value: resolved
        });
        break;
      }
      case `delete`: {
        const currentItem = ctx.collection.get(op.key);
        ctx.write({
          type: `delete`,
          value: currentItem
        });
        break;
      }
      case `upsert`: {
        const resolved = ctx.collection.validateData(
          op.data,
          ctx.collection.has(op.key) ? `update` : `insert`,
          op.key
        );
        if (ctx.collection.has(op.key)) {
          ctx.write({
            type: `update`,
            value: resolved
          });
        } else {
          ctx.write({
            type: `insert`,
            value: resolved
          });
        }
        break;
      }
    }
  }
  ctx.commit();
  const updatedData = ctx.collection.toArray;
  ctx.queryClient.setQueryData(ctx.queryKey, updatedData);
}
function createWriteUtils(getContext) {
  function ensureContext() {
    const context = getContext();
    if (!context) {
      throw new SyncNotInitializedError();
    }
    return context;
  }
  return {
    writeInsert(data) {
      const ctx = ensureContext();
      performWriteOperations({ type: `insert`, data }, ctx);
    },
    writeUpdate(data) {
      const ctx = ensureContext();
      performWriteOperations({ type: `update`, data }, ctx);
    },
    writeDelete(key) {
      const ctx = ensureContext();
      performWriteOperations({ type: `delete`, key }, ctx);
    },
    writeUpsert(data) {
      const ctx = ensureContext();
      performWriteOperations({ type: `upsert`, data }, ctx);
    },
    writeBatch(operations) {
      const ctx = ensureContext();
      performWriteOperations(operations, ctx);
    }
  };
}
export {
  createWriteUtils,
  performWriteOperations
};
//# sourceMappingURL=manual-sync.js.map
