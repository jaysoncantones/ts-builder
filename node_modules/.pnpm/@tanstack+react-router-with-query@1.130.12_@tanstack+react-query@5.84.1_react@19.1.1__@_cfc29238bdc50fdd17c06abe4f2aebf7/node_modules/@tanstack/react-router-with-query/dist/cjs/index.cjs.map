{"version":3,"file":"index.cjs","sources":["../../src/index.tsx"],"sourcesContent":["import { Fragment } from 'react'\nimport {\n  QueryClientProvider,\n  dehydrate as queryDehydrate,\n  hydrate as queryHydrate,\n} from '@tanstack/react-query'\nimport { isRedirect } from '@tanstack/router-core'\nimport '@tanstack/router-core/ssr/client'\nimport type { AnyRouter } from '@tanstack/react-router'\nimport type {\n  QueryClient,\n  DehydratedState as QueryDehydratedState,\n} from '@tanstack/react-query'\n\ntype AdditionalOptions = {\n  WrapProvider?: (props: { children: any }) => React.JSX.Element\n  /**\n   * If `true`, the QueryClient will handle errors thrown by `redirect()` inside of mutations and queries.\n   *\n   * @default true\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/api/router/redirectFunction)\n   */\n  handleRedirects?: boolean\n}\n\ntype DehydratedRouterQueryState = {\n  dehydratedQueryClient: QueryDehydratedState\n  queryStream: ReadableStream<QueryDehydratedState>\n}\nexport type ValidateRouter<TRouter extends AnyRouter> =\n  NonNullable<TRouter['options']['context']> extends {\n    queryClient: QueryClient\n  }\n    ? TRouter\n    : never\n\nexport function routerWithQueryClient<TRouter extends AnyRouter>(\n  router: ValidateRouter<TRouter>,\n  queryClient: QueryClient,\n  additionalOpts?: AdditionalOptions,\n): TRouter {\n  const ogOptions = router.options\n\n  router.options = {\n    ...router.options,\n    context: {\n      ...ogOptions.context,\n      // Pass the query client to the context, so we can access it in loaders\n      queryClient,\n    },\n    // Wrap the app in a QueryClientProvider\n    Wrap: ({ children }) => {\n      const OuterWrapper = additionalOpts?.WrapProvider || Fragment\n      const OGWrap = ogOptions.Wrap || Fragment\n      return (\n        <OuterWrapper>\n          <QueryClientProvider client={queryClient}>\n            <OGWrap>{children}</OGWrap>\n          </QueryClientProvider>\n        </OuterWrapper>\n      )\n    },\n  }\n\n  if (router.isServer) {\n    const queryStream = createPushableStream()\n\n    router.options.dehydrate =\n      async (): Promise<DehydratedRouterQueryState> => {\n        const ogDehydrated = await ogOptions.dehydrate?.()\n        const dehydratedQueryClient = queryDehydrate(queryClient)\n\n        router.serverSsr!.onRenderFinished(() => queryStream.close())\n\n        const dehydratedRouter = {\n          ...ogDehydrated,\n          // When critical data is dehydrated, we also dehydrate the query client\n          dehydratedQueryClient,\n          // prepare the stream for queries coming up during rendering\n          queryStream: queryStream.stream,\n        }\n\n        return dehydratedRouter\n      }\n\n    const ogClientOptions = queryClient.getDefaultOptions()\n    queryClient.setDefaultOptions({\n      ...ogClientOptions,\n      dehydrate: {\n        shouldDehydrateQuery: () => true,\n        ...ogClientOptions.dehydrate,\n      },\n    })\n\n    queryClient.getQueryCache().subscribe((event) => {\n      if (event.type === 'added') {\n        // before rendering starts, we do not stream individual queries\n        // instead we dehydrate the entire query client in router's dehydrate()\n        if (!router.serverSsr!.isDehydrated()) {\n          return\n        }\n        if (queryStream.isClosed()) {\n          console.warn(\n            `tried to stream query ${event.query.queryHash} after stream was already closed`,\n          )\n          return\n        }\n        queryStream.enqueue(\n          queryDehydrate(queryClient, {\n            shouldDehydrateQuery: (query) => {\n              if (query.queryHash === event.query.queryHash) {\n                return (\n                  ogClientOptions.dehydrate?.shouldDehydrateQuery?.(query) ??\n                  true\n                )\n              }\n              return false\n            },\n          }),\n        )\n      }\n    })\n    // on the client\n  } else {\n    router.options.hydrate = async (dehydrated: DehydratedRouterQueryState) => {\n      await ogOptions.hydrate?.(dehydrated)\n      // On the client, hydrate the query client with the dehydrated data\n      queryHydrate(queryClient, dehydrated.dehydratedQueryClient)\n\n      const reader = dehydrated.queryStream.getReader()\n      reader\n        .read()\n        .then(async function handle({ done, value }) {\n          queryHydrate(queryClient, value)\n          if (done) {\n            return\n          }\n          const result = await reader.read()\n          return handle(result)\n        })\n        .catch((err) => {\n          console.error('Error reading query stream:', err)\n        })\n    }\n    if (additionalOpts?.handleRedirects ?? true) {\n      const ogMutationCacheConfig = queryClient.getMutationCache().config\n      queryClient.getMutationCache().config = {\n        ...ogMutationCacheConfig,\n        onError: (error, _variables, _context, _mutation) => {\n          if (isRedirect(error)) {\n            error.options._fromLocation = router.state.location\n            return router.navigate(router.resolveRedirect(error).options)\n          }\n\n          return ogMutationCacheConfig.onError?.(\n            error,\n            _variables,\n            _context,\n            _mutation,\n          )\n        },\n      }\n\n      const ogQueryCacheConfig = queryClient.getQueryCache().config\n      queryClient.getQueryCache().config = {\n        ...ogQueryCacheConfig,\n        onError: (error, _query) => {\n          if (isRedirect(error)) {\n            error.options._fromLocation = router.state.location\n            return router.navigate(router.resolveRedirect(error).options)\n          }\n\n          return ogQueryCacheConfig.onError?.(error, _query)\n        },\n      }\n    }\n  }\n\n  return router\n}\n\ntype PushableStream = {\n  stream: ReadableStream\n  enqueue: (chunk: unknown) => void\n  close: () => void\n  isClosed: () => boolean\n  error: (err: unknown) => void\n}\n\nfunction createPushableStream(): PushableStream {\n  let controllerRef: ReadableStreamDefaultController\n  const stream = new ReadableStream({\n    start(controller) {\n      controllerRef = controller\n    },\n  })\n  let _isClosed = false\n\n  return {\n    stream,\n    enqueue: (chunk) => controllerRef.enqueue(chunk),\n    close: () => {\n      controllerRef.close()\n      _isClosed = true\n    },\n    isClosed: () => _isClosed,\n    error: (err: unknown) => controllerRef.error(err),\n  }\n}\n"],"names":["Fragment","jsx","QueryClientProvider","queryDehydrate","queryHydrate","isRedirect"],"mappings":"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"}